{
  "version": 3,
  "sources": ["../../src/lib/vis/animated_charts/node_modules/svgpath/lib/path_parse.js", "../../src/lib/vis/animated_charts/node_modules/svgpath/lib/matrix.js", "../../src/lib/vis/animated_charts/node_modules/svgpath/lib/transform_parse.js", "../../src/lib/vis/animated_charts/node_modules/svgpath/lib/a2c.js", "../../src/lib/vis/animated_charts/node_modules/svgpath/lib/ellipse.js", "../../src/lib/vis/animated_charts/node_modules/svgpath/lib/svgpath.js", "../../src/lib/vis/animated_charts/node_modules/svgpath/index.js", "dep:svgpath"],
  "sourcesContent": ["'use strict';\n\n\nvar paramCounts = { a: 7, c: 6, h: 1, l: 2, m: 2, r: 4, q: 4, s: 4, t: 2, v: 1, z: 0 };\n\nvar SPECIAL_SPACES = [\n  0x1680, 0x180E, 0x2000, 0x2001, 0x2002, 0x2003, 0x2004, 0x2005, 0x2006,\n  0x2007, 0x2008, 0x2009, 0x200A, 0x202F, 0x205F, 0x3000, 0xFEFF\n];\n\nfunction isSpace(ch) {\n  return (ch === 0x0A) || (ch === 0x0D) || (ch === 0x2028) || (ch === 0x2029) || // Line terminators\n    // White spaces\n    (ch === 0x20) || (ch === 0x09) || (ch === 0x0B) || (ch === 0x0C) || (ch === 0xA0) ||\n    (ch >= 0x1680 && SPECIAL_SPACES.indexOf(ch) >= 0);\n}\n\nfunction isCommand(code) {\n  /*eslint-disable no-bitwise*/\n  switch (code | 0x20) {\n    case 0x6D/* m */:\n    case 0x7A/* z */:\n    case 0x6C/* l */:\n    case 0x68/* h */:\n    case 0x76/* v */:\n    case 0x63/* c */:\n    case 0x73/* s */:\n    case 0x71/* q */:\n    case 0x74/* t */:\n    case 0x61/* a */:\n    case 0x72/* r */:\n      return true;\n  }\n  return false;\n}\n\nfunction isArc(code) {\n  return (code | 0x20) === 0x61;\n}\n\nfunction isDigit(code) {\n  return (code >= 48 && code <= 57);   // 0..9\n}\n\nfunction isDigitStart(code) {\n  return (code >= 48 && code <= 57) || /* 0..9 */\n          code === 0x2B || /* + */\n          code === 0x2D || /* - */\n          code === 0x2E;   /* . */\n}\n\n\nfunction State(path) {\n  this.index  = 0;\n  this.path   = path;\n  this.max    = path.length;\n  this.result = [];\n  this.param  = 0.0;\n  this.err    = '';\n  this.segmentStart = 0;\n  this.data   = [];\n}\n\nfunction skipSpaces(state) {\n  while (state.index < state.max && isSpace(state.path.charCodeAt(state.index))) {\n    state.index++;\n  }\n}\n\n\nfunction scanFlag(state) {\n  var ch = state.path.charCodeAt(state.index);\n\n  if (ch === 0x30/* 0 */) {\n    state.param = 0;\n    state.index++;\n    return;\n  }\n\n  if (ch === 0x31/* 1 */) {\n    state.param = 1;\n    state.index++;\n    return;\n  }\n\n  state.err = 'SvgPath: arc flag can be 0 or 1 only (at pos ' + state.index + ')';\n}\n\n\nfunction scanParam(state) {\n  var start = state.index,\n      index = start,\n      max = state.max,\n      zeroFirst = false,\n      hasCeiling = false,\n      hasDecimal = false,\n      hasDot = false,\n      ch;\n\n  if (index >= max) {\n    state.err = 'SvgPath: missed param (at pos ' + index + ')';\n    return;\n  }\n  ch = state.path.charCodeAt(index);\n\n  if (ch === 0x2B/* + */ || ch === 0x2D/* - */) {\n    index++;\n    ch = (index < max) ? state.path.charCodeAt(index) : 0;\n  }\n\n  // This logic is shamelessly borrowed from Esprima\n  // https://github.com/ariya/esprimas\n  //\n  if (!isDigit(ch) && ch !== 0x2E/* . */) {\n    state.err = 'SvgPath: param should start with 0..9 or `.` (at pos ' + index + ')';\n    return;\n  }\n\n  if (ch !== 0x2E/* . */) {\n    zeroFirst = (ch === 0x30/* 0 */);\n    index++;\n\n    ch = (index < max) ? state.path.charCodeAt(index) : 0;\n\n    if (zeroFirst && index < max) {\n      // decimal number starts with '0' such as '09' is illegal.\n      if (ch && isDigit(ch)) {\n        state.err = 'SvgPath: numbers started with `0` such as `09` are illegal (at pos ' + start + ')';\n        return;\n      }\n    }\n\n    while (index < max && isDigit(state.path.charCodeAt(index))) {\n      index++;\n      hasCeiling = true;\n    }\n    ch = (index < max) ? state.path.charCodeAt(index) : 0;\n  }\n\n  if (ch === 0x2E/* . */) {\n    hasDot = true;\n    index++;\n    while (isDigit(state.path.charCodeAt(index))) {\n      index++;\n      hasDecimal = true;\n    }\n    ch = (index < max) ? state.path.charCodeAt(index) : 0;\n  }\n\n  if (ch === 0x65/* e */ || ch === 0x45/* E */) {\n    if (hasDot && !hasCeiling && !hasDecimal) {\n      state.err = 'SvgPath: invalid float exponent (at pos ' + index + ')';\n      return;\n    }\n\n    index++;\n\n    ch = (index < max) ? state.path.charCodeAt(index) : 0;\n    if (ch === 0x2B/* + */ || ch === 0x2D/* - */) {\n      index++;\n    }\n    if (index < max && isDigit(state.path.charCodeAt(index))) {\n      while (index < max && isDigit(state.path.charCodeAt(index))) {\n        index++;\n      }\n    } else {\n      state.err = 'SvgPath: invalid float exponent (at pos ' + index + ')';\n      return;\n    }\n  }\n\n  state.index = index;\n  state.param = parseFloat(state.path.slice(start, index)) + 0.0;\n}\n\n\nfunction finalizeSegment(state) {\n  var cmd, cmdLC;\n\n  // Process duplicated commands (without comand name)\n\n  // This logic is shamelessly borrowed from Raphael\n  // https://github.com/DmitryBaranovskiy/raphael/\n  //\n  cmd   = state.path[state.segmentStart];\n  cmdLC = cmd.toLowerCase();\n\n  var params = state.data;\n\n  if (cmdLC === 'm' && params.length > 2) {\n    state.result.push([ cmd, params[0], params[1] ]);\n    params = params.slice(2);\n    cmdLC = 'l';\n    cmd = (cmd === 'm') ? 'l' : 'L';\n  }\n\n  if (cmdLC === 'r') {\n    state.result.push([ cmd ].concat(params));\n  } else {\n\n    while (params.length >= paramCounts[cmdLC]) {\n      state.result.push([ cmd ].concat(params.splice(0, paramCounts[cmdLC])));\n      if (!paramCounts[cmdLC]) {\n        break;\n      }\n    }\n  }\n}\n\n\nfunction scanSegment(state) {\n  var max = state.max,\n      cmdCode, is_arc, comma_found, need_params, i;\n\n  state.segmentStart = state.index;\n  cmdCode = state.path.charCodeAt(state.index);\n  is_arc = isArc(cmdCode);\n\n  if (!isCommand(cmdCode)) {\n    state.err = 'SvgPath: bad command ' + state.path[state.index] + ' (at pos ' + state.index + ')';\n    return;\n  }\n\n  need_params = paramCounts[state.path[state.index].toLowerCase()];\n\n  state.index++;\n  skipSpaces(state);\n\n  state.data = [];\n\n  if (!need_params) {\n    // Z\n    finalizeSegment(state);\n    return;\n  }\n\n  comma_found = false;\n\n  for (;;) {\n    for (i = need_params; i > 0; i--) {\n      if (is_arc && (i === 3 || i === 4)) scanFlag(state);\n      else scanParam(state);\n\n      if (state.err.length) {\n        return;\n      }\n      state.data.push(state.param);\n\n      skipSpaces(state);\n      comma_found = false;\n\n      if (state.index < max && state.path.charCodeAt(state.index) === 0x2C/* , */) {\n        state.index++;\n        skipSpaces(state);\n        comma_found = true;\n      }\n    }\n\n    // after ',' param is mandatory\n    if (comma_found) {\n      continue;\n    }\n\n    if (state.index >= state.max) {\n      break;\n    }\n\n    // Stop on next segment\n    if (!isDigitStart(state.path.charCodeAt(state.index))) {\n      break;\n    }\n  }\n\n  finalizeSegment(state);\n}\n\n\n/* Returns array of segments:\n *\n * [\n *   [ command, coord1, coord2, ... ]\n * ]\n */\nmodule.exports = function pathParse(svgPath) {\n  var state = new State(svgPath);\n  var max = state.max;\n\n  skipSpaces(state);\n\n  while (state.index < max && !state.err.length) {\n    scanSegment(state);\n  }\n\n  if (state.err.length) {\n    state.result = [];\n\n  } else if (state.result.length) {\n\n    if ('mM'.indexOf(state.result[0][0]) < 0) {\n      state.err = 'SvgPath: string should start with `M` or `m`';\n      state.result = [];\n    } else {\n      state.result[0][0] = 'M';\n    }\n  }\n\n  return {\n    err: state.err,\n    segments: state.result\n  };\n};\n", "'use strict';\n\n// combine 2 matrixes\n// m1, m2 - [a, b, c, d, e, g]\n//\nfunction combine(m1, m2) {\n  return [\n    m1[0] * m2[0] + m1[2] * m2[1],\n    m1[1] * m2[0] + m1[3] * m2[1],\n    m1[0] * m2[2] + m1[2] * m2[3],\n    m1[1] * m2[2] + m1[3] * m2[3],\n    m1[0] * m2[4] + m1[2] * m2[5] + m1[4],\n    m1[1] * m2[4] + m1[3] * m2[5] + m1[5]\n  ];\n}\n\n\nfunction Matrix() {\n  if (!(this instanceof Matrix)) { return new Matrix(); }\n  this.queue = [];   // list of matrixes to apply\n  this.cache = null; // combined matrix cache\n}\n\n\nMatrix.prototype.matrix = function (m) {\n  if (m[0] === 1 && m[1] === 0 && m[2] === 0 && m[3] === 1 && m[4] === 0 && m[5] === 0) {\n    return this;\n  }\n  this.cache = null;\n  this.queue.push(m);\n  return this;\n};\n\n\nMatrix.prototype.translate = function (tx, ty) {\n  if (tx !== 0 || ty !== 0) {\n    this.cache = null;\n    this.queue.push([ 1, 0, 0, 1, tx, ty ]);\n  }\n  return this;\n};\n\n\nMatrix.prototype.scale = function (sx, sy) {\n  if (sx !== 1 || sy !== 1) {\n    this.cache = null;\n    this.queue.push([ sx, 0, 0, sy, 0, 0 ]);\n  }\n  return this;\n};\n\n\nMatrix.prototype.rotate = function (angle, rx, ry) {\n  var rad, cos, sin;\n\n  if (angle !== 0) {\n    this.translate(rx, ry);\n\n    rad = angle * Math.PI / 180;\n    cos = Math.cos(rad);\n    sin = Math.sin(rad);\n\n    this.queue.push([ cos, sin, -sin, cos, 0, 0 ]);\n    this.cache = null;\n\n    this.translate(-rx, -ry);\n  }\n  return this;\n};\n\n\nMatrix.prototype.skewX = function (angle) {\n  if (angle !== 0) {\n    this.cache = null;\n    this.queue.push([ 1, 0, Math.tan(angle * Math.PI / 180), 1, 0, 0 ]);\n  }\n  return this;\n};\n\n\nMatrix.prototype.skewY = function (angle) {\n  if (angle !== 0) {\n    this.cache = null;\n    this.queue.push([ 1, Math.tan(angle * Math.PI / 180), 0, 1, 0, 0 ]);\n  }\n  return this;\n};\n\n\n// Flatten queue\n//\nMatrix.prototype.toArray = function () {\n  if (this.cache) {\n    return this.cache;\n  }\n\n  if (!this.queue.length) {\n    this.cache = [ 1, 0, 0, 1, 0, 0 ];\n    return this.cache;\n  }\n\n  this.cache = this.queue[0];\n\n  if (this.queue.length === 1) {\n    return this.cache;\n  }\n\n  for (var i = 1; i < this.queue.length; i++) {\n    this.cache = combine(this.cache, this.queue[i]);\n  }\n\n  return this.cache;\n};\n\n\n// Apply list of matrixes to (x,y) point.\n// If `isRelative` set, `translate` component of matrix will be skipped\n//\nMatrix.prototype.calc = function (x, y, isRelative) {\n  var m;\n\n  // Don't change point on empty transforms queue\n  if (!this.queue.length) { return [ x, y ]; }\n\n  // Calculate final matrix, if not exists\n  //\n  // NB. if you deside to apply transforms to point one-by-one,\n  // they should be taken in reverse order\n\n  if (!this.cache) {\n    this.cache = this.toArray();\n  }\n\n  m = this.cache;\n\n  // Apply matrix to point\n  return [\n    x * m[0] + y * m[2] + (isRelative ? 0 : m[4]),\n    x * m[1] + y * m[3] + (isRelative ? 0 : m[5])\n  ];\n};\n\n\nmodule.exports = Matrix;\n", "'use strict';\n\n\nvar Matrix = require('./matrix');\n\nvar operations = {\n  matrix: true,\n  scale: true,\n  rotate: true,\n  translate: true,\n  skewX: true,\n  skewY: true\n};\n\nvar CMD_SPLIT_RE    = /\\s*(matrix|translate|scale|rotate|skewX|skewY)\\s*\\(\\s*(.+?)\\s*\\)[\\s,]*/;\nvar PARAMS_SPLIT_RE = /[\\s,]+/;\n\n\nmodule.exports = function transformParse(transformString) {\n  var matrix = new Matrix();\n  var cmd, params;\n\n  // Split value into ['', 'translate', '10 50', '', 'scale', '2', '', 'rotate',  '-45', '']\n  transformString.split(CMD_SPLIT_RE).forEach(function (item) {\n\n    // Skip empty elements\n    if (!item.length) { return; }\n\n    // remember operation\n    if (typeof operations[item] !== 'undefined') {\n      cmd = item;\n      return;\n    }\n\n    // extract params & att operation to matrix\n    params = item.split(PARAMS_SPLIT_RE).map(function (i) {\n      return +i || 0;\n    });\n\n    // If params count is not correct - ignore command\n    switch (cmd) {\n      case 'matrix':\n        if (params.length === 6) {\n          matrix.matrix(params);\n        }\n        return;\n\n      case 'scale':\n        if (params.length === 1) {\n          matrix.scale(params[0], params[0]);\n        } else if (params.length === 2) {\n          matrix.scale(params[0], params[1]);\n        }\n        return;\n\n      case 'rotate':\n        if (params.length === 1) {\n          matrix.rotate(params[0], 0, 0);\n        } else if (params.length === 3) {\n          matrix.rotate(params[0], params[1], params[2]);\n        }\n        return;\n\n      case 'translate':\n        if (params.length === 1) {\n          matrix.translate(params[0], 0);\n        } else if (params.length === 2) {\n          matrix.translate(params[0], params[1]);\n        }\n        return;\n\n      case 'skewX':\n        if (params.length === 1) {\n          matrix.skewX(params[0]);\n        }\n        return;\n\n      case 'skewY':\n        if (params.length === 1) {\n          matrix.skewY(params[0]);\n        }\n        return;\n    }\n  });\n\n  return matrix;\n};\n", "// Convert an arc to a sequence of cubic b\u00E9zier curves\n//\n'use strict';\n\n\nvar TAU = Math.PI * 2;\n\n\n/* eslint-disable space-infix-ops */\n\n// Calculate an angle between two unit vectors\n//\n// Since we measure angle between radii of circular arcs,\n// we can use simplified math (without length normalization)\n//\nfunction unit_vector_angle(ux, uy, vx, vy) {\n  var sign = (ux * vy - uy * vx < 0) ? -1 : 1;\n  var dot  = ux * vx + uy * vy;\n\n  // Add this to work with arbitrary vectors:\n  // dot /= Math.sqrt(ux * ux + uy * uy) * Math.sqrt(vx * vx + vy * vy);\n\n  // rounding errors, e.g. -1.0000000000000002 can screw up this\n  if (dot >  1.0) { dot =  1.0; }\n  if (dot < -1.0) { dot = -1.0; }\n\n  return sign * Math.acos(dot);\n}\n\n\n// Convert from endpoint to center parameterization,\n// see http://www.w3.org/TR/SVG11/implnote.html#ArcImplementationNotes\n//\n// Return [cx, cy, theta1, delta_theta]\n//\nfunction get_arc_center(x1, y1, x2, y2, fa, fs, rx, ry, sin_phi, cos_phi) {\n  // Step 1.\n  //\n  // Moving an ellipse so origin will be the middlepoint between our two\n  // points. After that, rotate it to line up ellipse axes with coordinate\n  // axes.\n  //\n  var x1p =  cos_phi*(x1-x2)/2 + sin_phi*(y1-y2)/2;\n  var y1p = -sin_phi*(x1-x2)/2 + cos_phi*(y1-y2)/2;\n\n  var rx_sq  =  rx * rx;\n  var ry_sq  =  ry * ry;\n  var x1p_sq = x1p * x1p;\n  var y1p_sq = y1p * y1p;\n\n  // Step 2.\n  //\n  // Compute coordinates of the centre of this ellipse (cx', cy')\n  // in the new coordinate system.\n  //\n  var radicant = (rx_sq * ry_sq) - (rx_sq * y1p_sq) - (ry_sq * x1p_sq);\n\n  if (radicant < 0) {\n    // due to rounding errors it might be e.g. -1.3877787807814457e-17\n    radicant = 0;\n  }\n\n  radicant /=   (rx_sq * y1p_sq) + (ry_sq * x1p_sq);\n  radicant = Math.sqrt(radicant) * (fa === fs ? -1 : 1);\n\n  var cxp = radicant *  rx/ry * y1p;\n  var cyp = radicant * -ry/rx * x1p;\n\n  // Step 3.\n  //\n  // Transform back to get centre coordinates (cx, cy) in the original\n  // coordinate system.\n  //\n  var cx = cos_phi*cxp - sin_phi*cyp + (x1+x2)/2;\n  var cy = sin_phi*cxp + cos_phi*cyp + (y1+y2)/2;\n\n  // Step 4.\n  //\n  // Compute angles (theta1, delta_theta).\n  //\n  var v1x =  (x1p - cxp) / rx;\n  var v1y =  (y1p - cyp) / ry;\n  var v2x = (-x1p - cxp) / rx;\n  var v2y = (-y1p - cyp) / ry;\n\n  var theta1 = unit_vector_angle(1, 0, v1x, v1y);\n  var delta_theta = unit_vector_angle(v1x, v1y, v2x, v2y);\n\n  if (fs === 0 && delta_theta > 0) {\n    delta_theta -= TAU;\n  }\n  if (fs === 1 && delta_theta < 0) {\n    delta_theta += TAU;\n  }\n\n  return [ cx, cy, theta1, delta_theta ];\n}\n\n//\n// Approximate one unit arc segment with b\u00E9zier curves,\n// see http://math.stackexchange.com/questions/873224\n//\nfunction approximate_unit_arc(theta1, delta_theta) {\n  var alpha = 4/3 * Math.tan(delta_theta/4);\n\n  var x1 = Math.cos(theta1);\n  var y1 = Math.sin(theta1);\n  var x2 = Math.cos(theta1 + delta_theta);\n  var y2 = Math.sin(theta1 + delta_theta);\n\n  return [ x1, y1, x1 - y1*alpha, y1 + x1*alpha, x2 + y2*alpha, y2 - x2*alpha, x2, y2 ];\n}\n\nmodule.exports = function a2c(x1, y1, x2, y2, fa, fs, rx, ry, phi) {\n  var sin_phi = Math.sin(phi * TAU / 360);\n  var cos_phi = Math.cos(phi * TAU / 360);\n\n  // Make sure radii are valid\n  //\n  var x1p =  cos_phi*(x1-x2)/2 + sin_phi*(y1-y2)/2;\n  var y1p = -sin_phi*(x1-x2)/2 + cos_phi*(y1-y2)/2;\n\n  if (x1p === 0 && y1p === 0) {\n    // we're asked to draw line to itself\n    return [];\n  }\n\n  if (rx === 0 || ry === 0) {\n    // one of the radii is zero\n    return [];\n  }\n\n\n  // Compensate out-of-range radii\n  //\n  rx = Math.abs(rx);\n  ry = Math.abs(ry);\n\n  var lambda = (x1p * x1p) / (rx * rx) + (y1p * y1p) / (ry * ry);\n  if (lambda > 1) {\n    rx *= Math.sqrt(lambda);\n    ry *= Math.sqrt(lambda);\n  }\n\n\n  // Get center parameters (cx, cy, theta1, delta_theta)\n  //\n  var cc = get_arc_center(x1, y1, x2, y2, fa, fs, rx, ry, sin_phi, cos_phi);\n\n  var result = [];\n  var theta1 = cc[2];\n  var delta_theta = cc[3];\n\n  // Split an arc to multiple segments, so each segment\n  // will be less than \u03C4/4 (= 90\u00B0)\n  //\n  var segments = Math.max(Math.ceil(Math.abs(delta_theta) / (TAU / 4)), 1);\n  delta_theta /= segments;\n\n  for (var i = 0; i < segments; i++) {\n    result.push(approximate_unit_arc(theta1, delta_theta));\n    theta1 += delta_theta;\n  }\n\n  // We have a bezier approximation of a unit circle,\n  // now need to transform back to the original ellipse\n  //\n  return result.map(function (curve) {\n    for (var i = 0; i < curve.length; i += 2) {\n      var x = curve[i + 0];\n      var y = curve[i + 1];\n\n      // scale\n      x *= rx;\n      y *= ry;\n\n      // rotate\n      var xp = cos_phi*x - sin_phi*y;\n      var yp = sin_phi*x + cos_phi*y;\n\n      // translate\n      curve[i + 0] = xp + cc[0];\n      curve[i + 1] = yp + cc[1];\n    }\n\n    return curve;\n  });\n};\n", "'use strict';\n\n/* eslint-disable space-infix-ops */\n\n// The precision used to consider an ellipse as a circle\n//\nvar epsilon = 0.0000000001;\n\n// To convert degree in radians\n//\nvar torad = Math.PI / 180;\n\n// Class constructor :\n//  an ellipse centred at 0 with radii rx,ry and x - axis - angle ax.\n//\nfunction Ellipse(rx, ry, ax) {\n  if (!(this instanceof Ellipse)) { return new Ellipse(rx, ry, ax); }\n  this.rx = rx;\n  this.ry = ry;\n  this.ax = ax;\n}\n\n// Apply a linear transform m to the ellipse\n// m is an array representing a matrix :\n//    -         -\n//   | m[0] m[2] |\n//   | m[1] m[3] |\n//    -         -\n//\nEllipse.prototype.transform = function (m) {\n  // We consider the current ellipse as image of the unit circle\n  // by first scale(rx,ry) and then rotate(ax) ...\n  // So we apply ma =  m x rotate(ax) x scale(rx,ry) to the unit circle.\n  var c = Math.cos(this.ax * torad), s = Math.sin(this.ax * torad);\n  var ma = [\n    this.rx * (m[0]*c + m[2]*s),\n    this.rx * (m[1]*c + m[3]*s),\n    this.ry * (-m[0]*s + m[2]*c),\n    this.ry * (-m[1]*s + m[3]*c)\n  ];\n\n  // ma * transpose(ma) = [ J L ]\n  //                      [ L K ]\n  // L is calculated later (if the image is not a circle)\n  var J = ma[0]*ma[0] + ma[2]*ma[2],\n      K = ma[1]*ma[1] + ma[3]*ma[3];\n\n  // the discriminant of the characteristic polynomial of ma * transpose(ma)\n  var D = ((ma[0]-ma[3])*(ma[0]-ma[3]) + (ma[2]+ma[1])*(ma[2]+ma[1])) *\n          ((ma[0]+ma[3])*(ma[0]+ma[3]) + (ma[2]-ma[1])*(ma[2]-ma[1]));\n\n  // the \"mean eigenvalue\"\n  var JK = (J + K) / 2;\n\n  // check if the image is (almost) a circle\n  if (D < epsilon * JK) {\n    // if it is\n    this.rx = this.ry = Math.sqrt(JK);\n    this.ax = 0;\n    return this;\n  }\n\n  // if it is not a circle\n  var L = ma[0]*ma[1] + ma[2]*ma[3];\n\n  D = Math.sqrt(D);\n\n  // {l1,l2} = the two eigen values of ma * transpose(ma)\n  var l1 = JK + D/2,\n      l2 = JK - D/2;\n  // the x - axis - rotation angle is the argument of the l1 - eigenvector\n  /*eslint-disable indent*/\n  this.ax = (Math.abs(L) < epsilon && Math.abs(l1 - K) < epsilon) ?\n    90\n  :\n    Math.atan(Math.abs(L) > Math.abs(l1 - K) ?\n      (l1 - J) / L\n    :\n      L / (l1 - K)\n    ) * 180 / Math.PI;\n  /*eslint-enable indent*/\n\n  // if ax > 0 => rx = sqrt(l1), ry = sqrt(l2), else exchange axes and ax += 90\n  if (this.ax >= 0) {\n    // if ax in [0,90]\n    this.rx = Math.sqrt(l1);\n    this.ry = Math.sqrt(l2);\n  } else {\n    // if ax in ]-90,0[ => exchange axes\n    this.ax += 90;\n    this.rx = Math.sqrt(l2);\n    this.ry = Math.sqrt(l1);\n  }\n\n  return this;\n};\n\n// Check if the ellipse is (almost) degenerate, i.e. rx = 0 or ry = 0\n//\nEllipse.prototype.isDegenerate = function () {\n  return (this.rx < epsilon * this.ry || this.ry < epsilon * this.rx);\n};\n\nmodule.exports = Ellipse;\n", "// SVG Path transformations library\n//\n// Usage:\n//\n//    SvgPath('...')\n//      .translate(-150, -100)\n//      .scale(0.5)\n//      .translate(-150, -100)\n//      .toFixed(1)\n//      .toString()\n//\n\n'use strict';\n\n\nvar pathParse      = require('./path_parse');\nvar transformParse = require('./transform_parse');\nvar matrix         = require('./matrix');\nvar a2c            = require('./a2c');\nvar ellipse        = require('./ellipse');\n\n\n// Class constructor\n//\nfunction SvgPath(path) {\n  if (!(this instanceof SvgPath)) { return new SvgPath(path); }\n\n  var pstate = pathParse(path);\n\n  // Array of path segments.\n  // Each segment is array [command, param1, param2, ...]\n  this.segments = pstate.segments;\n\n  // Error message on parse error.\n  this.err      = pstate.err;\n\n  // Transforms stack for lazy evaluation\n  this.__stack    = [];\n}\n\nSvgPath.from = function (src) {\n  if (typeof src === 'string') return new SvgPath(src);\n\n  if (src instanceof SvgPath) {\n    // Create empty object\n    var s = new SvgPath('');\n\n    // Clone properies\n    s.err = src.err;\n    s.segments = src.segments.map(function (sgm) { return sgm.slice(); });\n    s.__stack = src.__stack.map(function (m) {\n      return matrix().matrix(m.toArray());\n    });\n\n    return s;\n  }\n\n  throw new Error('SvgPath.from: invalid param type ' + src);\n};\n\n\nSvgPath.prototype.__matrix = function (m) {\n  var self = this, i;\n\n  // Quick leave for empty matrix\n  if (!m.queue.length) { return; }\n\n  this.iterate(function (s, index, x, y) {\n    var p, result, name, isRelative;\n\n    switch (s[0]) {\n\n      // Process 'assymetric' commands separately\n      case 'v':\n        p      = m.calc(0, s[1], true);\n        result = (p[0] === 0) ? [ 'v', p[1] ] : [ 'l', p[0], p[1] ];\n        break;\n\n      case 'V':\n        p      = m.calc(x, s[1], false);\n        result = (p[0] === m.calc(x, y, false)[0]) ? [ 'V', p[1] ] : [ 'L', p[0], p[1] ];\n        break;\n\n      case 'h':\n        p      = m.calc(s[1], 0, true);\n        result = (p[1] === 0) ? [ 'h', p[0] ] : [ 'l', p[0], p[1] ];\n        break;\n\n      case 'H':\n        p      = m.calc(s[1], y, false);\n        result = (p[1] === m.calc(x, y, false)[1]) ? [ 'H', p[0] ] : [ 'L', p[0], p[1] ];\n        break;\n\n      case 'a':\n      case 'A':\n        // ARC is: ['A', rx, ry, x-axis-rotation, large-arc-flag, sweep-flag, x, y]\n\n        // Drop segment if arc is empty (end point === start point)\n        /*if ((s[0] === 'A' && s[6] === x && s[7] === y) ||\n            (s[0] === 'a' && s[6] === 0 && s[7] === 0)) {\n          return [];\n        }*/\n\n        // Transform rx, ry and the x-axis-rotation\n        var ma = m.toArray();\n        var e = ellipse(s[1], s[2], s[3]).transform(ma);\n\n        // flip sweep-flag if matrix is not orientation-preserving\n        if (ma[0] * ma[3] - ma[1] * ma[2] < 0) {\n          s[5] = s[5] ? '0' : '1';\n        }\n\n        // Transform end point as usual (without translation for relative notation)\n        p = m.calc(s[6], s[7], s[0] === 'a');\n\n        // Empty arcs can be ignored by renderer, but should not be dropped\n        // to avoid collisions with `S A S` and so on. Replace with empty line.\n        if ((s[0] === 'A' && s[6] === x && s[7] === y) ||\n            (s[0] === 'a' && s[6] === 0 && s[7] === 0)) {\n          result = [ s[0] === 'a' ? 'l' : 'L', p[0], p[1] ];\n          break;\n        }\n\n        // if the resulting ellipse is (almost) a segment ...\n        if (e.isDegenerate()) {\n          // replace the arc by a line\n          result = [ s[0] === 'a' ? 'l' : 'L', p[0], p[1] ];\n        } else {\n          // if it is a real ellipse\n          // s[0], s[4] and s[5] are not modified\n          result = [ s[0], e.rx, e.ry, e.ax, s[4], s[5], p[0], p[1] ];\n        }\n\n        break;\n\n      case 'm':\n        // Edge case. The very first `m` should be processed as absolute, if happens.\n        // Make sense for coord shift transforms.\n        isRelative = index > 0;\n\n        p = m.calc(s[1], s[2], isRelative);\n        result = [ 'm', p[0], p[1] ];\n        break;\n\n      default:\n        name       = s[0];\n        result     = [ name ];\n        isRelative = (name.toLowerCase() === name);\n\n        // Apply transformations to the segment\n        for (i = 1; i < s.length; i += 2) {\n          p = m.calc(s[i], s[i + 1], isRelative);\n          result.push(p[0], p[1]);\n        }\n    }\n\n    self.segments[index] = result;\n  }, true);\n};\n\n\n// Apply stacked commands\n//\nSvgPath.prototype.__evaluateStack = function () {\n  var m, i;\n\n  if (!this.__stack.length) { return; }\n\n  if (this.__stack.length === 1) {\n    this.__matrix(this.__stack[0]);\n    this.__stack = [];\n    return;\n  }\n\n  m = matrix();\n  i = this.__stack.length;\n\n  while (--i >= 0) {\n    m.matrix(this.__stack[i].toArray());\n  }\n\n  this.__matrix(m);\n  this.__stack = [];\n};\n\n\n// Convert processed SVG Path back to string\n//\nSvgPath.prototype.toString = function () {\n  var result = '', prevCmd = '', cmdSkipped = false;\n\n  this.__evaluateStack();\n\n  for (var i = 0, len = this.segments.length; i < len; i++) {\n    var segment = this.segments[i];\n    var cmd = segment[0];\n\n    // Command not repeating => store\n    if (cmd !== prevCmd || cmd === 'm' || cmd === 'M') {\n      // workaround for FontForge SVG importing bug, keep space between \"z m\".\n      if (cmd === 'm' && prevCmd === 'z') result += ' ';\n      result += cmd;\n\n      cmdSkipped = false;\n    } else {\n      cmdSkipped = true;\n    }\n\n    // Store segment params\n    for (var pos = 1; pos < segment.length; pos++) {\n      var val = segment[pos];\n      // Space can be skipped\n      // 1. After command (always)\n      // 2. For negative value (with '-' at start)\n      if (pos === 1) {\n        if (cmdSkipped && val >= 0) result += ' ';\n      } else if (val >= 0) result += ' ';\n\n      result += val;\n    }\n\n    prevCmd = cmd;\n  }\n\n  return result;\n};\n\n\n// Translate path to (x [, y])\n//\nSvgPath.prototype.translate = function (x, y) {\n  this.__stack.push(matrix().translate(x, y || 0));\n  return this;\n};\n\n\n// Scale path to (sx [, sy])\n// sy = sx if not defined\n//\nSvgPath.prototype.scale = function (sx, sy) {\n  this.__stack.push(matrix().scale(sx, (!sy && (sy !== 0)) ? sx : sy));\n  return this;\n};\n\n\n// Rotate path around point (sx [, sy])\n// sy = sx if not defined\n//\nSvgPath.prototype.rotate = function (angle, rx, ry) {\n  this.__stack.push(matrix().rotate(angle, rx || 0, ry || 0));\n  return this;\n};\n\n\n// Skew path along the X axis by `degrees` angle\n//\nSvgPath.prototype.skewX = function (degrees) {\n  this.__stack.push(matrix().skewX(degrees));\n  return this;\n};\n\n\n// Skew path along the Y axis by `degrees` angle\n//\nSvgPath.prototype.skewY = function (degrees) {\n  this.__stack.push(matrix().skewY(degrees));\n  return this;\n};\n\n\n// Apply matrix transform (array of 6 elements)\n//\nSvgPath.prototype.matrix = function (m) {\n  this.__stack.push(matrix().matrix(m));\n  return this;\n};\n\n\n// Transform path according to \"transform\" attr of SVG spec\n//\nSvgPath.prototype.transform = function (transformString) {\n  if (!transformString.trim()) {\n    return this;\n  }\n  this.__stack.push(transformParse(transformString));\n  return this;\n};\n\n\n// Round coords with given decimal precition.\n// 0 by default (to integers)\n//\nSvgPath.prototype.round = function (d) {\n  var contourStartDeltaX = 0, contourStartDeltaY = 0, deltaX = 0, deltaY = 0, l;\n\n  d = d || 0;\n\n  this.__evaluateStack();\n\n  this.segments.forEach(function (s) {\n    var isRelative = (s[0].toLowerCase() === s[0]);\n\n    switch (s[0]) {\n      case 'H':\n      case 'h':\n        if (isRelative) { s[1] += deltaX; }\n        deltaX = s[1] - s[1].toFixed(d);\n        s[1] = +s[1].toFixed(d);\n        return;\n\n      case 'V':\n      case 'v':\n        if (isRelative) { s[1] += deltaY; }\n        deltaY = s[1] - s[1].toFixed(d);\n        s[1] = +s[1].toFixed(d);\n        return;\n\n      case 'Z':\n      case 'z':\n        deltaX = contourStartDeltaX;\n        deltaY = contourStartDeltaY;\n        return;\n\n      case 'M':\n      case 'm':\n        if (isRelative) {\n          s[1] += deltaX;\n          s[2] += deltaY;\n        }\n\n        deltaX = s[1] - s[1].toFixed(d);\n        deltaY = s[2] - s[2].toFixed(d);\n\n        contourStartDeltaX = deltaX;\n        contourStartDeltaY = deltaY;\n\n        s[1] = +s[1].toFixed(d);\n        s[2] = +s[2].toFixed(d);\n        return;\n\n      case 'A':\n      case 'a':\n        // [cmd, rx, ry, x-axis-rotation, large-arc-flag, sweep-flag, x, y]\n        if (isRelative) {\n          s[6] += deltaX;\n          s[7] += deltaY;\n        }\n\n        deltaX = s[6] - s[6].toFixed(d);\n        deltaY = s[7] - s[7].toFixed(d);\n\n        s[1] = +s[1].toFixed(d);\n        s[2] = +s[2].toFixed(d);\n        s[3] = +s[3].toFixed(d + 2); // better precision for rotation\n        s[6] = +s[6].toFixed(d);\n        s[7] = +s[7].toFixed(d);\n        return;\n\n      default:\n        // a c l q s t\n        l = s.length;\n\n        if (isRelative) {\n          s[l - 2] += deltaX;\n          s[l - 1] += deltaY;\n        }\n\n        deltaX = s[l - 2] - s[l - 2].toFixed(d);\n        deltaY = s[l - 1] - s[l - 1].toFixed(d);\n\n        s.forEach(function (val, i) {\n          if (!i) { return; }\n          s[i] = +s[i].toFixed(d);\n        });\n        return;\n    }\n  });\n\n  return this;\n};\n\n\n// Apply iterator function to all segments. If function returns result,\n// current segment will be replaced to array of returned segments.\n// If empty array is returned, current regment will be deleted.\n//\nSvgPath.prototype.iterate = function (iterator, keepLazyStack) {\n  var segments = this.segments,\n      replacements = {},\n      needReplace = false,\n      lastX = 0,\n      lastY = 0,\n      countourStartX = 0,\n      countourStartY = 0;\n  var i, j, newSegments;\n\n  if (!keepLazyStack) {\n    this.__evaluateStack();\n  }\n\n  segments.forEach(function (s, index) {\n\n    var res = iterator(s, index, lastX, lastY);\n\n    if (Array.isArray(res)) {\n      replacements[index] = res;\n      needReplace = true;\n    }\n\n    var isRelative = (s[0] === s[0].toLowerCase());\n\n    // calculate absolute X and Y\n    switch (s[0]) {\n      case 'm':\n      case 'M':\n        lastX = s[1] + (isRelative ? lastX : 0);\n        lastY = s[2] + (isRelative ? lastY : 0);\n        countourStartX = lastX;\n        countourStartY = lastY;\n        return;\n\n      case 'h':\n      case 'H':\n        lastX = s[1] + (isRelative ? lastX : 0);\n        return;\n\n      case 'v':\n      case 'V':\n        lastY = s[1] + (isRelative ? lastY : 0);\n        return;\n\n      case 'z':\n      case 'Z':\n        // That make sence for multiple contours\n        lastX = countourStartX;\n        lastY = countourStartY;\n        return;\n\n      default:\n        lastX = s[s.length - 2] + (isRelative ? lastX : 0);\n        lastY = s[s.length - 1] + (isRelative ? lastY : 0);\n    }\n  });\n\n  // Replace segments if iterator return results\n\n  if (!needReplace) { return this; }\n\n  newSegments = [];\n\n  for (i = 0; i < segments.length; i++) {\n    if (typeof replacements[i] !== 'undefined') {\n      for (j = 0; j < replacements[i].length; j++) {\n        newSegments.push(replacements[i][j]);\n      }\n    } else {\n      newSegments.push(segments[i]);\n    }\n  }\n\n  this.segments = newSegments;\n\n  return this;\n};\n\n\n// Converts segments from relative to absolute\n//\nSvgPath.prototype.abs = function () {\n\n  this.iterate(function (s, index, x, y) {\n    var name = s[0],\n        nameUC = name.toUpperCase(),\n        i;\n\n    // Skip absolute commands\n    if (name === nameUC) { return; }\n\n    s[0] = nameUC;\n\n    switch (name) {\n      case 'v':\n        // v has shifted coords parity\n        s[1] += y;\n        return;\n\n      case 'a':\n        // ARC is: ['A', rx, ry, x-axis-rotation, large-arc-flag, sweep-flag, x, y]\n        // touch x, y only\n        s[6] += x;\n        s[7] += y;\n        return;\n\n      default:\n        for (i = 1; i < s.length; i++) {\n          s[i] += i % 2 ? x : y; // odd values are X, even - Y\n        }\n    }\n  }, true);\n\n  return this;\n};\n\n\n// Converts segments from absolute to relative\n//\nSvgPath.prototype.rel = function () {\n\n  this.iterate(function (s, index, x, y) {\n    var name = s[0],\n        nameLC = name.toLowerCase(),\n        i;\n\n    // Skip relative commands\n    if (name === nameLC) { return; }\n\n    // Don't touch the first M to avoid potential confusions.\n    if (index === 0 && name === 'M') { return; }\n\n    s[0] = nameLC;\n\n    switch (name) {\n      case 'V':\n        // V has shifted coords parity\n        s[1] -= y;\n        return;\n\n      case 'A':\n        // ARC is: ['A', rx, ry, x-axis-rotation, large-arc-flag, sweep-flag, x, y]\n        // touch x, y only\n        s[6] -= x;\n        s[7] -= y;\n        return;\n\n      default:\n        for (i = 1; i < s.length; i++) {\n          s[i] -= i % 2 ? x : y; // odd values are X, even - Y\n        }\n    }\n  }, true);\n\n  return this;\n};\n\n\n// Converts arcs to cubic b\u00E9zier curves\n//\nSvgPath.prototype.unarc = function () {\n  this.iterate(function (s, index, x, y) {\n    var new_segments, nextX, nextY, result = [], name = s[0];\n\n    // Skip anything except arcs\n    if (name !== 'A' && name !== 'a') { return null; }\n\n    if (name === 'a') {\n      // convert relative arc coordinates to absolute\n      nextX = x + s[6];\n      nextY = y + s[7];\n    } else {\n      nextX = s[6];\n      nextY = s[7];\n    }\n\n    new_segments = a2c(x, y, nextX, nextY, s[4], s[5], s[1], s[2], s[3]);\n\n    // Degenerated arcs can be ignored by renderer, but should not be dropped\n    // to avoid collisions with `S A S` and so on. Replace with empty line.\n    if (new_segments.length === 0) {\n      return [ [ s[0] === 'a' ? 'l' : 'L', s[6], s[7] ] ];\n    }\n\n    new_segments.forEach(function (s) {\n      result.push([ 'C', s[2], s[3], s[4], s[5], s[6], s[7] ]);\n    });\n\n    return result;\n  });\n\n  return this;\n};\n\n\n// Converts smooth curves (with missed control point) to generic curves\n//\nSvgPath.prototype.unshort = function () {\n  var segments = this.segments;\n  var prevControlX, prevControlY, prevSegment;\n  var curControlX, curControlY;\n\n  // TODO: add lazy evaluation flag when relative commands supported\n\n  this.iterate(function (s, idx, x, y) {\n    var name = s[0], nameUC = name.toUpperCase(), isRelative;\n\n    // First command MUST be M|m, it's safe to skip.\n    // Protect from access to [-1] for sure.\n    if (!idx) { return; }\n\n    if (nameUC === 'T') { // quadratic curve\n      isRelative = (name === 't');\n\n      prevSegment = segments[idx - 1];\n\n      if (prevSegment[0] === 'Q') {\n        prevControlX = prevSegment[1] - x;\n        prevControlY = prevSegment[2] - y;\n      } else if (prevSegment[0] === 'q') {\n        prevControlX = prevSegment[1] - prevSegment[3];\n        prevControlY = prevSegment[2] - prevSegment[4];\n      } else {\n        prevControlX = 0;\n        prevControlY = 0;\n      }\n\n      curControlX = -prevControlX;\n      curControlY = -prevControlY;\n\n      if (!isRelative) {\n        curControlX += x;\n        curControlY += y;\n      }\n\n      segments[idx] = [\n        isRelative ? 'q' : 'Q',\n        curControlX, curControlY,\n        s[1], s[2]\n      ];\n\n    } else if (nameUC === 'S') { // cubic curve\n      isRelative = (name === 's');\n\n      prevSegment = segments[idx - 1];\n\n      if (prevSegment[0] === 'C') {\n        prevControlX = prevSegment[3] - x;\n        prevControlY = prevSegment[4] - y;\n      } else if (prevSegment[0] === 'c') {\n        prevControlX = prevSegment[3] - prevSegment[5];\n        prevControlY = prevSegment[4] - prevSegment[6];\n      } else {\n        prevControlX = 0;\n        prevControlY = 0;\n      }\n\n      curControlX = -prevControlX;\n      curControlY = -prevControlY;\n\n      if (!isRelative) {\n        curControlX += x;\n        curControlY += y;\n      }\n\n      segments[idx] = [\n        isRelative ? 'c' : 'C',\n        curControlX, curControlY,\n        s[1], s[2], s[3], s[4]\n      ];\n    }\n  });\n\n  return this;\n};\n\n\nmodule.exports = SvgPath;\n", "'use strict';\n\nmodule.exports = require('./lib/svgpath');\n", "export default require(\"./src/lib/vis/animated_charts/node_modules/svgpath/index.js\");"],
  "mappings": "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",
  "names": []
}
