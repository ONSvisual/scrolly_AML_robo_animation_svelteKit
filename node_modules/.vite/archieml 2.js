import {
  __commonJS
} from "./chunk-ESTXZSVW.js";

// node_modules/archieml/archieml.js
var require_archieml = __commonJS({
  "node_modules/archieml/archieml.js"(exports, module) {
    (function() {
      "use strict";
      function load(input, options) {
        var whitespacePattern = "\\u0000\\u0009\\u000A\\u000B\\u000C\\u000D\\u0020\\u00A0\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200A\\u200B\\u2028\\u2029\\u202F\\u205F\\u3000\\uFEFF";
        var slugBlacklist = whitespacePattern + "\\u005B\\u005C\\u005D\\u007B\\u007D\\u003A";
        var nextLine = new RegExp(".*((\r|\n)+)");
        var startKey = new RegExp("^\\s*([^" + slugBlacklist + "]+)[ 	\r]*:[ 	\r]*(.*(?:\n|\r|$))");
        var commandKey = new RegExp("^\\s*:[ 	\r]*(endskip|ignore|skip|end).*?(\n|\r|$)", "i");
        var arrayElement = new RegExp("^\\s*\\*[ 	\r]*(.*(?:\n|\r|$))");
        var scopePattern = new RegExp("^\\s*(\\[|\\{)[ 	\r]*([+.]*)[ 	\r]*([^" + slugBlacklist + "]*)[ 	\r]*(?:\\]|\\}).*?(\n|\r|$)");
        var data = {}, scope = data, stack = [], stackScope = void 0, bufferScope = null, bufferKey = null, bufferString = "", isSkipping = false;
        var options = options || {};
        if (options.comments !== true)
          options.comments = false;
        while (input) {
          var match;
          if (commandKey.exec(input)) {
            match = commandKey.exec(input);
            parseCommandKey(match[1].toLowerCase());
          } else if (!isSkipping && startKey.exec(input) && (!stackScope || stackScope.arrayType !== "simple")) {
            match = startKey.exec(input);
            parseStartKey(match[1], match[2] || "");
          } else if (!isSkipping && arrayElement.exec(input) && stackScope && stackScope.array && (stackScope.arrayType !== "complex" && stackScope.arrayType !== "freeform") && stackScope.flags.indexOf("+") < 0) {
            match = arrayElement.exec(input);
            parseArrayElement(match[1]);
          } else if (!isSkipping && scopePattern.exec(input)) {
            match = scopePattern.exec(input);
            parseScope(match[1], match[2], match[3]);
          } else if (nextLine.exec(input)) {
            match = nextLine.exec(input);
            parseText(match[0]);
          } else {
            parseText(input);
            input = "";
          }
          if (match)
            input = input.substring(match[0].length);
        }
        function parseStartKey(key, restOfLine) {
          flushBuffer();
          incrementArrayElement(key);
          if (stackScope && stackScope.flags.indexOf("+") > -1)
            key = "value";
          bufferKey = key;
          bufferString = restOfLine;
          flushBufferInto(key, { replace: true });
        }
        function parseArrayElement(value) {
          flushBuffer();
          stackScope.arrayType = stackScope.arrayType || "simple";
          stackScope.array.push("");
          bufferKey = stackScope.array;
          bufferString = value;
          flushBufferInto(stackScope.array, { replace: true });
        }
        function parseCommandKey(command) {
          if (isSkipping && !(command === "endskip" || command === "ignore"))
            return flushBuffer();
          switch (command) {
            case "end":
              if (bufferKey)
                flushBufferInto(bufferKey, { replace: false });
              return;
            case "ignore":
              input = "";
              break;
            case "skip":
              isSkipping = true;
              break;
            case "endskip":
              isSkipping = false;
              break;
          }
          flushBuffer();
        }
        function parseScope(scopeType, flags, scopeKey) {
          flushBuffer();
          if (scopeKey == "") {
            var lastStackItem = stack.pop();
            scope = (lastStackItem ? lastStackItem.scope : data) || data;
            stackScope = stack[stack.length - 1];
          } else if (scopeType === "[" || scopeType === "{") {
            var nesting = false;
            var keyScope = data;
            if (flags.indexOf(".") > -1) {
              incrementArrayElement(scopeKey, flags);
              nesting = true;
              if (stackScope)
                keyScope = scope;
            } else {
              scope = data;
              stack = [];
            }
            if (stackScope && stackScope.flags.indexOf("+") > -1) {
              var parsedScopeKey = scopeKey;
            } else {
              var keyBits = scopeKey.split(".");
              for (var i = 0; i < keyBits.length - 1; i++) {
                keyScope = keyScope[keyBits[i]] = keyScope[keyBits[i]] || {};
              }
              var parsedScopeKey = keyBits[keyBits.length - 1];
            }
            var stackScopeItem = {
              array: null,
              arrayType: null,
              arrayFirstKey: null,
              flags,
              scope
            };
            var isNestedFreeform = stackScope && stackScope.flags.indexOf("+") > -1 && flags.indexOf(".") > -1;
            if (scopeType == "[") {
              if (isNestedFreeform)
                parsedScopeKey = "value";
              stackScopeItem.array = keyScope[parsedScopeKey] = [];
              if (flags.indexOf("+") > -1)
                stackScopeItem.arrayType = "freeform";
              if (nesting) {
                stack.push(stackScopeItem);
              } else {
                stack = [stackScopeItem];
              }
              stackScope = stack[stack.length - 1];
            } else if (scopeType == "{") {
              if (nesting) {
                if (isNestedFreeform)
                  scope = scope.value = {};
                else
                  scope = keyScope[parsedScopeKey] = keyScope = {};
                stack.push(stackScopeItem);
              } else {
                scope = keyScope[parsedScopeKey] = typeof keyScope[parsedScopeKey] === "object" ? keyScope[parsedScopeKey] : {};
                stack = [stackScopeItem];
              }
              stackScope = stack[stack.length - 1];
            }
          }
        }
        function parseText(text) {
          if (stackScope && stackScope.flags.indexOf("+") > -1 && text.match(/[^\n\r\s]/)) {
            stackScope.array.push({ "type": "text", "value": text.replace(/(^\s*)|(\s*$)/g, "") });
          } else {
            bufferString += input.substring(0, text.length);
          }
        }
        function incrementArrayElement(key) {
          if (stackScope && stackScope.array) {
            stackScope.arrayType = stackScope.arrayType || "complex";
            if (stackScope.arrayType === "simple")
              return;
            if (stackScope.arrayFirstKey === null || stackScope.arrayFirstKey === key)
              stackScope.array.push(scope = {});
            if (stackScope.flags.indexOf("+") > -1) {
              scope.type = key;
            } else {
              stackScope.arrayFirstKey = stackScope.arrayFirstKey || key;
            }
          }
        }
        function formatValue(value, type) {
          if (options.comments) {
            value = value.replace(/(?:^\\)?\[[^\[\]\n\r]*\](?!\])/mg, "");
            value = value.replace(/\[\[([^\[\]\n\r]*)\]\]/g, "[$1]");
          }
          if (type == "append") {
            value = value.replace(new RegExp("^(\\s*)\\\\", "gm"), "$1");
          }
          return value;
        }
        function flushBuffer() {
          var result = bufferString + "";
          bufferString = "";
          bufferKey = null;
          return result;
        }
        function flushBufferInto(key, options2) {
          options2 = options2 || {};
          var existingBufferKey = bufferKey;
          var value = flushBuffer();
          if (options2.replace) {
            value = formatValue(value, "replace").replace(new RegExp("^\\s*"), "");
            bufferString = new RegExp("\\s*$").exec(value)[0];
            bufferKey = existingBufferKey;
          } else {
            value = formatValue(value, "append");
          }
          if (typeof key === "object") {
            if (options2.replace)
              key[key.length - 1] = "";
            key[key.length - 1] += value.replace(new RegExp("\\s*$"), "");
          } else {
            var keyBits = key.split(".");
            bufferScope = scope;
            for (var i = 0; i < keyBits.length - 1; i++) {
              if (typeof bufferScope[keyBits[i]] === "string")
                bufferScope[keyBits[i]] = {};
              bufferScope = bufferScope[keyBits[i]] = bufferScope[keyBits[i]] || {};
            }
            if (options2.replace)
              bufferScope[keyBits[keyBits.length - 1]] = "";
            bufferScope[keyBits[keyBits.length - 1]] += value.replace(new RegExp("\\s*$"), "");
          }
        }
        flushBuffer();
        return data;
      }
      var root = this;
      var archieml = { load };
      if (typeof exports !== "undefined") {
        if (typeof module !== "undefined" && module.exports) {
          exports = module.exports = archieml;
        }
        exports.archieml = archieml;
      } else {
        this.archieml = archieml;
      }
      if (typeof define === "function" && define.amd) {
        define("archieml", [], function() {
          return archieml;
        });
      }
    }).call(exports);
  }
});

// dep:archieml
var archieml_default = require_archieml();
export {
  archieml_default as default
};
//# sourceMappingURL=archieml.js.map
