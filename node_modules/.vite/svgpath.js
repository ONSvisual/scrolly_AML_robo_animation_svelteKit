import {
  __commonJS
} from "./chunk-OL3AADLO.js";

// node_modules/svgpath/lib/path_parse.js
var require_path_parse = __commonJS({
  "node_modules/svgpath/lib/path_parse.js"(exports, module) {
    "use strict";
    var paramCounts = { a: 7, c: 6, h: 1, l: 2, m: 2, r: 4, q: 4, s: 4, t: 2, v: 1, z: 0 };
    var SPECIAL_SPACES = [
      5760,
      6158,
      8192,
      8193,
      8194,
      8195,
      8196,
      8197,
      8198,
      8199,
      8200,
      8201,
      8202,
      8239,
      8287,
      12288,
      65279
    ];
    function isSpace(ch) {
      return ch === 10 || ch === 13 || ch === 8232 || ch === 8233 || ch === 32 || ch === 9 || ch === 11 || ch === 12 || ch === 160 || ch >= 5760 && SPECIAL_SPACES.indexOf(ch) >= 0;
    }
    function isCommand(code) {
      switch (code | 32) {
        case 109:
        case 122:
        case 108:
        case 104:
        case 118:
        case 99:
        case 115:
        case 113:
        case 116:
        case 97:
        case 114:
          return true;
      }
      return false;
    }
    function isArc(code) {
      return (code | 32) === 97;
    }
    function isDigit(code) {
      return code >= 48 && code <= 57;
    }
    function isDigitStart(code) {
      return code >= 48 && code <= 57 || code === 43 || code === 45 || code === 46;
    }
    function State(path) {
      this.index = 0;
      this.path = path;
      this.max = path.length;
      this.result = [];
      this.param = 0;
      this.err = "";
      this.segmentStart = 0;
      this.data = [];
    }
    function skipSpaces(state) {
      while (state.index < state.max && isSpace(state.path.charCodeAt(state.index))) {
        state.index++;
      }
    }
    function scanFlag(state) {
      var ch = state.path.charCodeAt(state.index);
      if (ch === 48) {
        state.param = 0;
        state.index++;
        return;
      }
      if (ch === 49) {
        state.param = 1;
        state.index++;
        return;
      }
      state.err = "SvgPath: arc flag can be 0 or 1 only (at pos " + state.index + ")";
    }
    function scanParam(state) {
      var start = state.index, index = start, max = state.max, zeroFirst = false, hasCeiling = false, hasDecimal = false, hasDot = false, ch;
      if (index >= max) {
        state.err = "SvgPath: missed param (at pos " + index + ")";
        return;
      }
      ch = state.path.charCodeAt(index);
      if (ch === 43 || ch === 45) {
        index++;
        ch = index < max ? state.path.charCodeAt(index) : 0;
      }
      if (!isDigit(ch) && ch !== 46) {
        state.err = "SvgPath: param should start with 0..9 or `.` (at pos " + index + ")";
        return;
      }
      if (ch !== 46) {
        zeroFirst = ch === 48;
        index++;
        ch = index < max ? state.path.charCodeAt(index) : 0;
        if (zeroFirst && index < max) {
          if (ch && isDigit(ch)) {
            state.err = "SvgPath: numbers started with `0` such as `09` are illegal (at pos " + start + ")";
            return;
          }
        }
        while (index < max && isDigit(state.path.charCodeAt(index))) {
          index++;
          hasCeiling = true;
        }
        ch = index < max ? state.path.charCodeAt(index) : 0;
      }
      if (ch === 46) {
        hasDot = true;
        index++;
        while (isDigit(state.path.charCodeAt(index))) {
          index++;
          hasDecimal = true;
        }
        ch = index < max ? state.path.charCodeAt(index) : 0;
      }
      if (ch === 101 || ch === 69) {
        if (hasDot && !hasCeiling && !hasDecimal) {
          state.err = "SvgPath: invalid float exponent (at pos " + index + ")";
          return;
        }
        index++;
        ch = index < max ? state.path.charCodeAt(index) : 0;
        if (ch === 43 || ch === 45) {
          index++;
        }
        if (index < max && isDigit(state.path.charCodeAt(index))) {
          while (index < max && isDigit(state.path.charCodeAt(index))) {
            index++;
          }
        } else {
          state.err = "SvgPath: invalid float exponent (at pos " + index + ")";
          return;
        }
      }
      state.index = index;
      state.param = parseFloat(state.path.slice(start, index)) + 0;
    }
    function finalizeSegment(state) {
      var cmd, cmdLC;
      cmd = state.path[state.segmentStart];
      cmdLC = cmd.toLowerCase();
      var params = state.data;
      if (cmdLC === "m" && params.length > 2) {
        state.result.push([cmd, params[0], params[1]]);
        params = params.slice(2);
        cmdLC = "l";
        cmd = cmd === "m" ? "l" : "L";
      }
      if (cmdLC === "r") {
        state.result.push([cmd].concat(params));
      } else {
        while (params.length >= paramCounts[cmdLC]) {
          state.result.push([cmd].concat(params.splice(0, paramCounts[cmdLC])));
          if (!paramCounts[cmdLC]) {
            break;
          }
        }
      }
    }
    function scanSegment(state) {
      var max = state.max, cmdCode, is_arc, comma_found, need_params, i;
      state.segmentStart = state.index;
      cmdCode = state.path.charCodeAt(state.index);
      is_arc = isArc(cmdCode);
      if (!isCommand(cmdCode)) {
        state.err = "SvgPath: bad command " + state.path[state.index] + " (at pos " + state.index + ")";
        return;
      }
      need_params = paramCounts[state.path[state.index].toLowerCase()];
      state.index++;
      skipSpaces(state);
      state.data = [];
      if (!need_params) {
        finalizeSegment(state);
        return;
      }
      comma_found = false;
      for (; ; ) {
        for (i = need_params; i > 0; i--) {
          if (is_arc && (i === 3 || i === 4))
            scanFlag(state);
          else
            scanParam(state);
          if (state.err.length) {
            return;
          }
          state.data.push(state.param);
          skipSpaces(state);
          comma_found = false;
          if (state.index < max && state.path.charCodeAt(state.index) === 44) {
            state.index++;
            skipSpaces(state);
            comma_found = true;
          }
        }
        if (comma_found) {
          continue;
        }
        if (state.index >= state.max) {
          break;
        }
        if (!isDigitStart(state.path.charCodeAt(state.index))) {
          break;
        }
      }
      finalizeSegment(state);
    }
    module.exports = function pathParse(svgPath) {
      var state = new State(svgPath);
      var max = state.max;
      skipSpaces(state);
      while (state.index < max && !state.err.length) {
        scanSegment(state);
      }
      if (state.err.length) {
        state.result = [];
      } else if (state.result.length) {
        if ("mM".indexOf(state.result[0][0]) < 0) {
          state.err = "SvgPath: string should start with `M` or `m`";
          state.result = [];
        } else {
          state.result[0][0] = "M";
        }
      }
      return {
        err: state.err,
        segments: state.result
      };
    };
  }
});

// node_modules/svgpath/lib/matrix.js
var require_matrix = __commonJS({
  "node_modules/svgpath/lib/matrix.js"(exports, module) {
    "use strict";
    function combine(m1, m2) {
      return [
        m1[0] * m2[0] + m1[2] * m2[1],
        m1[1] * m2[0] + m1[3] * m2[1],
        m1[0] * m2[2] + m1[2] * m2[3],
        m1[1] * m2[2] + m1[3] * m2[3],
        m1[0] * m2[4] + m1[2] * m2[5] + m1[4],
        m1[1] * m2[4] + m1[3] * m2[5] + m1[5]
      ];
    }
    function Matrix() {
      if (!(this instanceof Matrix)) {
        return new Matrix();
      }
      this.queue = [];
      this.cache = null;
    }
    Matrix.prototype.matrix = function(m) {
      if (m[0] === 1 && m[1] === 0 && m[2] === 0 && m[3] === 1 && m[4] === 0 && m[5] === 0) {
        return this;
      }
      this.cache = null;
      this.queue.push(m);
      return this;
    };
    Matrix.prototype.translate = function(tx, ty) {
      if (tx !== 0 || ty !== 0) {
        this.cache = null;
        this.queue.push([1, 0, 0, 1, tx, ty]);
      }
      return this;
    };
    Matrix.prototype.scale = function(sx, sy) {
      if (sx !== 1 || sy !== 1) {
        this.cache = null;
        this.queue.push([sx, 0, 0, sy, 0, 0]);
      }
      return this;
    };
    Matrix.prototype.rotate = function(angle, rx, ry) {
      var rad, cos, sin;
      if (angle !== 0) {
        this.translate(rx, ry);
        rad = angle * Math.PI / 180;
        cos = Math.cos(rad);
        sin = Math.sin(rad);
        this.queue.push([cos, sin, -sin, cos, 0, 0]);
        this.cache = null;
        this.translate(-rx, -ry);
      }
      return this;
    };
    Matrix.prototype.skewX = function(angle) {
      if (angle !== 0) {
        this.cache = null;
        this.queue.push([1, 0, Math.tan(angle * Math.PI / 180), 1, 0, 0]);
      }
      return this;
    };
    Matrix.prototype.skewY = function(angle) {
      if (angle !== 0) {
        this.cache = null;
        this.queue.push([1, Math.tan(angle * Math.PI / 180), 0, 1, 0, 0]);
      }
      return this;
    };
    Matrix.prototype.toArray = function() {
      if (this.cache) {
        return this.cache;
      }
      if (!this.queue.length) {
        this.cache = [1, 0, 0, 1, 0, 0];
        return this.cache;
      }
      this.cache = this.queue[0];
      if (this.queue.length === 1) {
        return this.cache;
      }
      for (var i = 1; i < this.queue.length; i++) {
        this.cache = combine(this.cache, this.queue[i]);
      }
      return this.cache;
    };
    Matrix.prototype.calc = function(x, y, isRelative) {
      var m;
      if (!this.queue.length) {
        return [x, y];
      }
      if (!this.cache) {
        this.cache = this.toArray();
      }
      m = this.cache;
      return [
        x * m[0] + y * m[2] + (isRelative ? 0 : m[4]),
        x * m[1] + y * m[3] + (isRelative ? 0 : m[5])
      ];
    };
    module.exports = Matrix;
  }
});

// node_modules/svgpath/lib/transform_parse.js
var require_transform_parse = __commonJS({
  "node_modules/svgpath/lib/transform_parse.js"(exports, module) {
    "use strict";
    var Matrix = require_matrix();
    var operations = {
      matrix: true,
      scale: true,
      rotate: true,
      translate: true,
      skewX: true,
      skewY: true
    };
    var CMD_SPLIT_RE = /\s*(matrix|translate|scale|rotate|skewX|skewY)\s*\(\s*(.+?)\s*\)[\s,]*/;
    var PARAMS_SPLIT_RE = /[\s,]+/;
    module.exports = function transformParse(transformString) {
      var matrix = new Matrix();
      var cmd, params;
      transformString.split(CMD_SPLIT_RE).forEach(function(item) {
        if (!item.length) {
          return;
        }
        if (typeof operations[item] !== "undefined") {
          cmd = item;
          return;
        }
        params = item.split(PARAMS_SPLIT_RE).map(function(i) {
          return +i || 0;
        });
        switch (cmd) {
          case "matrix":
            if (params.length === 6) {
              matrix.matrix(params);
            }
            return;
          case "scale":
            if (params.length === 1) {
              matrix.scale(params[0], params[0]);
            } else if (params.length === 2) {
              matrix.scale(params[0], params[1]);
            }
            return;
          case "rotate":
            if (params.length === 1) {
              matrix.rotate(params[0], 0, 0);
            } else if (params.length === 3) {
              matrix.rotate(params[0], params[1], params[2]);
            }
            return;
          case "translate":
            if (params.length === 1) {
              matrix.translate(params[0], 0);
            } else if (params.length === 2) {
              matrix.translate(params[0], params[1]);
            }
            return;
          case "skewX":
            if (params.length === 1) {
              matrix.skewX(params[0]);
            }
            return;
          case "skewY":
            if (params.length === 1) {
              matrix.skewY(params[0]);
            }
            return;
        }
      });
      return matrix;
    };
  }
});

// node_modules/svgpath/lib/a2c.js
var require_a2c = __commonJS({
  "node_modules/svgpath/lib/a2c.js"(exports, module) {
    "use strict";
    var TAU = Math.PI * 2;
    function unit_vector_angle(ux, uy, vx, vy) {
      var sign = ux * vy - uy * vx < 0 ? -1 : 1;
      var dot = ux * vx + uy * vy;
      if (dot > 1) {
        dot = 1;
      }
      if (dot < -1) {
        dot = -1;
      }
      return sign * Math.acos(dot);
    }
    function get_arc_center(x1, y1, x2, y2, fa, fs, rx, ry, sin_phi, cos_phi) {
      var x1p = cos_phi * (x1 - x2) / 2 + sin_phi * (y1 - y2) / 2;
      var y1p = -sin_phi * (x1 - x2) / 2 + cos_phi * (y1 - y2) / 2;
      var rx_sq = rx * rx;
      var ry_sq = ry * ry;
      var x1p_sq = x1p * x1p;
      var y1p_sq = y1p * y1p;
      var radicant = rx_sq * ry_sq - rx_sq * y1p_sq - ry_sq * x1p_sq;
      if (radicant < 0) {
        radicant = 0;
      }
      radicant /= rx_sq * y1p_sq + ry_sq * x1p_sq;
      radicant = Math.sqrt(radicant) * (fa === fs ? -1 : 1);
      var cxp = radicant * rx / ry * y1p;
      var cyp = radicant * -ry / rx * x1p;
      var cx = cos_phi * cxp - sin_phi * cyp + (x1 + x2) / 2;
      var cy = sin_phi * cxp + cos_phi * cyp + (y1 + y2) / 2;
      var v1x = (x1p - cxp) / rx;
      var v1y = (y1p - cyp) / ry;
      var v2x = (-x1p - cxp) / rx;
      var v2y = (-y1p - cyp) / ry;
      var theta1 = unit_vector_angle(1, 0, v1x, v1y);
      var delta_theta = unit_vector_angle(v1x, v1y, v2x, v2y);
      if (fs === 0 && delta_theta > 0) {
        delta_theta -= TAU;
      }
      if (fs === 1 && delta_theta < 0) {
        delta_theta += TAU;
      }
      return [cx, cy, theta1, delta_theta];
    }
    function approximate_unit_arc(theta1, delta_theta) {
      var alpha = 4 / 3 * Math.tan(delta_theta / 4);
      var x1 = Math.cos(theta1);
      var y1 = Math.sin(theta1);
      var x2 = Math.cos(theta1 + delta_theta);
      var y2 = Math.sin(theta1 + delta_theta);
      return [x1, y1, x1 - y1 * alpha, y1 + x1 * alpha, x2 + y2 * alpha, y2 - x2 * alpha, x2, y2];
    }
    module.exports = function a2c(x1, y1, x2, y2, fa, fs, rx, ry, phi) {
      var sin_phi = Math.sin(phi * TAU / 360);
      var cos_phi = Math.cos(phi * TAU / 360);
      var x1p = cos_phi * (x1 - x2) / 2 + sin_phi * (y1 - y2) / 2;
      var y1p = -sin_phi * (x1 - x2) / 2 + cos_phi * (y1 - y2) / 2;
      if (x1p === 0 && y1p === 0) {
        return [];
      }
      if (rx === 0 || ry === 0) {
        return [];
      }
      rx = Math.abs(rx);
      ry = Math.abs(ry);
      var lambda = x1p * x1p / (rx * rx) + y1p * y1p / (ry * ry);
      if (lambda > 1) {
        rx *= Math.sqrt(lambda);
        ry *= Math.sqrt(lambda);
      }
      var cc = get_arc_center(x1, y1, x2, y2, fa, fs, rx, ry, sin_phi, cos_phi);
      var result = [];
      var theta1 = cc[2];
      var delta_theta = cc[3];
      var segments = Math.max(Math.ceil(Math.abs(delta_theta) / (TAU / 4)), 1);
      delta_theta /= segments;
      for (var i = 0; i < segments; i++) {
        result.push(approximate_unit_arc(theta1, delta_theta));
        theta1 += delta_theta;
      }
      return result.map(function(curve) {
        for (var i2 = 0; i2 < curve.length; i2 += 2) {
          var x = curve[i2 + 0];
          var y = curve[i2 + 1];
          x *= rx;
          y *= ry;
          var xp = cos_phi * x - sin_phi * y;
          var yp = sin_phi * x + cos_phi * y;
          curve[i2 + 0] = xp + cc[0];
          curve[i2 + 1] = yp + cc[1];
        }
        return curve;
      });
    };
  }
});

// node_modules/svgpath/lib/ellipse.js
var require_ellipse = __commonJS({
  "node_modules/svgpath/lib/ellipse.js"(exports, module) {
    "use strict";
    var epsilon = 1e-10;
    var torad = Math.PI / 180;
    function Ellipse(rx, ry, ax) {
      if (!(this instanceof Ellipse)) {
        return new Ellipse(rx, ry, ax);
      }
      this.rx = rx;
      this.ry = ry;
      this.ax = ax;
    }
    Ellipse.prototype.transform = function(m) {
      var c = Math.cos(this.ax * torad), s = Math.sin(this.ax * torad);
      var ma = [
        this.rx * (m[0] * c + m[2] * s),
        this.rx * (m[1] * c + m[3] * s),
        this.ry * (-m[0] * s + m[2] * c),
        this.ry * (-m[1] * s + m[3] * c)
      ];
      var J = ma[0] * ma[0] + ma[2] * ma[2], K = ma[1] * ma[1] + ma[3] * ma[3];
      var D = ((ma[0] - ma[3]) * (ma[0] - ma[3]) + (ma[2] + ma[1]) * (ma[2] + ma[1])) * ((ma[0] + ma[3]) * (ma[0] + ma[3]) + (ma[2] - ma[1]) * (ma[2] - ma[1]));
      var JK = (J + K) / 2;
      if (D < epsilon * JK) {
        this.rx = this.ry = Math.sqrt(JK);
        this.ax = 0;
        return this;
      }
      var L = ma[0] * ma[1] + ma[2] * ma[3];
      D = Math.sqrt(D);
      var l1 = JK + D / 2, l2 = JK - D / 2;
      this.ax = Math.abs(L) < epsilon && Math.abs(l1 - K) < epsilon ? 90 : Math.atan(Math.abs(L) > Math.abs(l1 - K) ? (l1 - J) / L : L / (l1 - K)) * 180 / Math.PI;
      if (this.ax >= 0) {
        this.rx = Math.sqrt(l1);
        this.ry = Math.sqrt(l2);
      } else {
        this.ax += 90;
        this.rx = Math.sqrt(l2);
        this.ry = Math.sqrt(l1);
      }
      return this;
    };
    Ellipse.prototype.isDegenerate = function() {
      return this.rx < epsilon * this.ry || this.ry < epsilon * this.rx;
    };
    module.exports = Ellipse;
  }
});

// node_modules/svgpath/lib/svgpath.js
var require_svgpath = __commonJS({
  "node_modules/svgpath/lib/svgpath.js"(exports, module) {
    "use strict";
    var pathParse = require_path_parse();
    var transformParse = require_transform_parse();
    var matrix = require_matrix();
    var a2c = require_a2c();
    var ellipse = require_ellipse();
    function SvgPath(path) {
      if (!(this instanceof SvgPath)) {
        return new SvgPath(path);
      }
      var pstate = pathParse(path);
      this.segments = pstate.segments;
      this.err = pstate.err;
      this.__stack = [];
    }
    SvgPath.from = function(src) {
      if (typeof src === "string")
        return new SvgPath(src);
      if (src instanceof SvgPath) {
        var s = new SvgPath("");
        s.err = src.err;
        s.segments = src.segments.map(function(sgm) {
          return sgm.slice();
        });
        s.__stack = src.__stack.map(function(m) {
          return matrix().matrix(m.toArray());
        });
        return s;
      }
      throw new Error("SvgPath.from: invalid param type " + src);
    };
    SvgPath.prototype.__matrix = function(m) {
      var self = this, i;
      if (!m.queue.length) {
        return;
      }
      this.iterate(function(s, index, x, y) {
        var p, result, name, isRelative;
        switch (s[0]) {
          case "v":
            p = m.calc(0, s[1], true);
            result = p[0] === 0 ? ["v", p[1]] : ["l", p[0], p[1]];
            break;
          case "V":
            p = m.calc(x, s[1], false);
            result = p[0] === m.calc(x, y, false)[0] ? ["V", p[1]] : ["L", p[0], p[1]];
            break;
          case "h":
            p = m.calc(s[1], 0, true);
            result = p[1] === 0 ? ["h", p[0]] : ["l", p[0], p[1]];
            break;
          case "H":
            p = m.calc(s[1], y, false);
            result = p[1] === m.calc(x, y, false)[1] ? ["H", p[0]] : ["L", p[0], p[1]];
            break;
          case "a":
          case "A":
            var ma = m.toArray();
            var e = ellipse(s[1], s[2], s[3]).transform(ma);
            if (ma[0] * ma[3] - ma[1] * ma[2] < 0) {
              s[5] = s[5] ? "0" : "1";
            }
            p = m.calc(s[6], s[7], s[0] === "a");
            if (s[0] === "A" && s[6] === x && s[7] === y || s[0] === "a" && s[6] === 0 && s[7] === 0) {
              result = [s[0] === "a" ? "l" : "L", p[0], p[1]];
              break;
            }
            if (e.isDegenerate()) {
              result = [s[0] === "a" ? "l" : "L", p[0], p[1]];
            } else {
              result = [s[0], e.rx, e.ry, e.ax, s[4], s[5], p[0], p[1]];
            }
            break;
          case "m":
            isRelative = index > 0;
            p = m.calc(s[1], s[2], isRelative);
            result = ["m", p[0], p[1]];
            break;
          default:
            name = s[0];
            result = [name];
            isRelative = name.toLowerCase() === name;
            for (i = 1; i < s.length; i += 2) {
              p = m.calc(s[i], s[i + 1], isRelative);
              result.push(p[0], p[1]);
            }
        }
        self.segments[index] = result;
      }, true);
    };
    SvgPath.prototype.__evaluateStack = function() {
      var m, i;
      if (!this.__stack.length) {
        return;
      }
      if (this.__stack.length === 1) {
        this.__matrix(this.__stack[0]);
        this.__stack = [];
        return;
      }
      m = matrix();
      i = this.__stack.length;
      while (--i >= 0) {
        m.matrix(this.__stack[i].toArray());
      }
      this.__matrix(m);
      this.__stack = [];
    };
    SvgPath.prototype.toString = function() {
      var result = "", prevCmd = "", cmdSkipped = false;
      this.__evaluateStack();
      for (var i = 0, len = this.segments.length; i < len; i++) {
        var segment = this.segments[i];
        var cmd = segment[0];
        if (cmd !== prevCmd || cmd === "m" || cmd === "M") {
          if (cmd === "m" && prevCmd === "z")
            result += " ";
          result += cmd;
          cmdSkipped = false;
        } else {
          cmdSkipped = true;
        }
        for (var pos = 1; pos < segment.length; pos++) {
          var val = segment[pos];
          if (pos === 1) {
            if (cmdSkipped && val >= 0)
              result += " ";
          } else if (val >= 0)
            result += " ";
          result += val;
        }
        prevCmd = cmd;
      }
      return result;
    };
    SvgPath.prototype.translate = function(x, y) {
      this.__stack.push(matrix().translate(x, y || 0));
      return this;
    };
    SvgPath.prototype.scale = function(sx, sy) {
      this.__stack.push(matrix().scale(sx, !sy && sy !== 0 ? sx : sy));
      return this;
    };
    SvgPath.prototype.rotate = function(angle, rx, ry) {
      this.__stack.push(matrix().rotate(angle, rx || 0, ry || 0));
      return this;
    };
    SvgPath.prototype.skewX = function(degrees) {
      this.__stack.push(matrix().skewX(degrees));
      return this;
    };
    SvgPath.prototype.skewY = function(degrees) {
      this.__stack.push(matrix().skewY(degrees));
      return this;
    };
    SvgPath.prototype.matrix = function(m) {
      this.__stack.push(matrix().matrix(m));
      return this;
    };
    SvgPath.prototype.transform = function(transformString) {
      if (!transformString.trim()) {
        return this;
      }
      this.__stack.push(transformParse(transformString));
      return this;
    };
    SvgPath.prototype.round = function(d) {
      var contourStartDeltaX = 0, contourStartDeltaY = 0, deltaX = 0, deltaY = 0, l;
      d = d || 0;
      this.__evaluateStack();
      this.segments.forEach(function(s) {
        var isRelative = s[0].toLowerCase() === s[0];
        switch (s[0]) {
          case "H":
          case "h":
            if (isRelative) {
              s[1] += deltaX;
            }
            deltaX = s[1] - s[1].toFixed(d);
            s[1] = +s[1].toFixed(d);
            return;
          case "V":
          case "v":
            if (isRelative) {
              s[1] += deltaY;
            }
            deltaY = s[1] - s[1].toFixed(d);
            s[1] = +s[1].toFixed(d);
            return;
          case "Z":
          case "z":
            deltaX = contourStartDeltaX;
            deltaY = contourStartDeltaY;
            return;
          case "M":
          case "m":
            if (isRelative) {
              s[1] += deltaX;
              s[2] += deltaY;
            }
            deltaX = s[1] - s[1].toFixed(d);
            deltaY = s[2] - s[2].toFixed(d);
            contourStartDeltaX = deltaX;
            contourStartDeltaY = deltaY;
            s[1] = +s[1].toFixed(d);
            s[2] = +s[2].toFixed(d);
            return;
          case "A":
          case "a":
            if (isRelative) {
              s[6] += deltaX;
              s[7] += deltaY;
            }
            deltaX = s[6] - s[6].toFixed(d);
            deltaY = s[7] - s[7].toFixed(d);
            s[1] = +s[1].toFixed(d);
            s[2] = +s[2].toFixed(d);
            s[3] = +s[3].toFixed(d + 2);
            s[6] = +s[6].toFixed(d);
            s[7] = +s[7].toFixed(d);
            return;
          default:
            l = s.length;
            if (isRelative) {
              s[l - 2] += deltaX;
              s[l - 1] += deltaY;
            }
            deltaX = s[l - 2] - s[l - 2].toFixed(d);
            deltaY = s[l - 1] - s[l - 1].toFixed(d);
            s.forEach(function(val, i) {
              if (!i) {
                return;
              }
              s[i] = +s[i].toFixed(d);
            });
            return;
        }
      });
      return this;
    };
    SvgPath.prototype.iterate = function(iterator, keepLazyStack) {
      var segments = this.segments, replacements = {}, needReplace = false, lastX = 0, lastY = 0, countourStartX = 0, countourStartY = 0;
      var i, j, newSegments;
      if (!keepLazyStack) {
        this.__evaluateStack();
      }
      segments.forEach(function(s, index) {
        var res = iterator(s, index, lastX, lastY);
        if (Array.isArray(res)) {
          replacements[index] = res;
          needReplace = true;
        }
        var isRelative = s[0] === s[0].toLowerCase();
        switch (s[0]) {
          case "m":
          case "M":
            lastX = s[1] + (isRelative ? lastX : 0);
            lastY = s[2] + (isRelative ? lastY : 0);
            countourStartX = lastX;
            countourStartY = lastY;
            return;
          case "h":
          case "H":
            lastX = s[1] + (isRelative ? lastX : 0);
            return;
          case "v":
          case "V":
            lastY = s[1] + (isRelative ? lastY : 0);
            return;
          case "z":
          case "Z":
            lastX = countourStartX;
            lastY = countourStartY;
            return;
          default:
            lastX = s[s.length - 2] + (isRelative ? lastX : 0);
            lastY = s[s.length - 1] + (isRelative ? lastY : 0);
        }
      });
      if (!needReplace) {
        return this;
      }
      newSegments = [];
      for (i = 0; i < segments.length; i++) {
        if (typeof replacements[i] !== "undefined") {
          for (j = 0; j < replacements[i].length; j++) {
            newSegments.push(replacements[i][j]);
          }
        } else {
          newSegments.push(segments[i]);
        }
      }
      this.segments = newSegments;
      return this;
    };
    SvgPath.prototype.abs = function() {
      this.iterate(function(s, index, x, y) {
        var name = s[0], nameUC = name.toUpperCase(), i;
        if (name === nameUC) {
          return;
        }
        s[0] = nameUC;
        switch (name) {
          case "v":
            s[1] += y;
            return;
          case "a":
            s[6] += x;
            s[7] += y;
            return;
          default:
            for (i = 1; i < s.length; i++) {
              s[i] += i % 2 ? x : y;
            }
        }
      }, true);
      return this;
    };
    SvgPath.prototype.rel = function() {
      this.iterate(function(s, index, x, y) {
        var name = s[0], nameLC = name.toLowerCase(), i;
        if (name === nameLC) {
          return;
        }
        if (index === 0 && name === "M") {
          return;
        }
        s[0] = nameLC;
        switch (name) {
          case "V":
            s[1] -= y;
            return;
          case "A":
            s[6] -= x;
            s[7] -= y;
            return;
          default:
            for (i = 1; i < s.length; i++) {
              s[i] -= i % 2 ? x : y;
            }
        }
      }, true);
      return this;
    };
    SvgPath.prototype.unarc = function() {
      this.iterate(function(s, index, x, y) {
        var new_segments, nextX, nextY, result = [], name = s[0];
        if (name !== "A" && name !== "a") {
          return null;
        }
        if (name === "a") {
          nextX = x + s[6];
          nextY = y + s[7];
        } else {
          nextX = s[6];
          nextY = s[7];
        }
        new_segments = a2c(x, y, nextX, nextY, s[4], s[5], s[1], s[2], s[3]);
        if (new_segments.length === 0) {
          return [[s[0] === "a" ? "l" : "L", s[6], s[7]]];
        }
        new_segments.forEach(function(s2) {
          result.push(["C", s2[2], s2[3], s2[4], s2[5], s2[6], s2[7]]);
        });
        return result;
      });
      return this;
    };
    SvgPath.prototype.unshort = function() {
      var segments = this.segments;
      var prevControlX, prevControlY, prevSegment;
      var curControlX, curControlY;
      this.iterate(function(s, idx, x, y) {
        var name = s[0], nameUC = name.toUpperCase(), isRelative;
        if (!idx) {
          return;
        }
        if (nameUC === "T") {
          isRelative = name === "t";
          prevSegment = segments[idx - 1];
          if (prevSegment[0] === "Q") {
            prevControlX = prevSegment[1] - x;
            prevControlY = prevSegment[2] - y;
          } else if (prevSegment[0] === "q") {
            prevControlX = prevSegment[1] - prevSegment[3];
            prevControlY = prevSegment[2] - prevSegment[4];
          } else {
            prevControlX = 0;
            prevControlY = 0;
          }
          curControlX = -prevControlX;
          curControlY = -prevControlY;
          if (!isRelative) {
            curControlX += x;
            curControlY += y;
          }
          segments[idx] = [
            isRelative ? "q" : "Q",
            curControlX,
            curControlY,
            s[1],
            s[2]
          ];
        } else if (nameUC === "S") {
          isRelative = name === "s";
          prevSegment = segments[idx - 1];
          if (prevSegment[0] === "C") {
            prevControlX = prevSegment[3] - x;
            prevControlY = prevSegment[4] - y;
          } else if (prevSegment[0] === "c") {
            prevControlX = prevSegment[3] - prevSegment[5];
            prevControlY = prevSegment[4] - prevSegment[6];
          } else {
            prevControlX = 0;
            prevControlY = 0;
          }
          curControlX = -prevControlX;
          curControlY = -prevControlY;
          if (!isRelative) {
            curControlX += x;
            curControlY += y;
          }
          segments[idx] = [
            isRelative ? "c" : "C",
            curControlX,
            curControlY,
            s[1],
            s[2],
            s[3],
            s[4]
          ];
        }
      });
      return this;
    };
    module.exports = SvgPath;
  }
});

// node_modules/svgpath/index.js
var require_svgpath2 = __commonJS({
  "node_modules/svgpath/index.js"(exports, module) {
    "use strict";
    module.exports = require_svgpath();
  }
});

// dep:svgpath
var svgpath_default = require_svgpath2();
export {
  svgpath_default as default
};
//# sourceMappingURL=svgpath.js.map
