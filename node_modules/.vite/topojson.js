import {
  feature_default,
  transform_default
} from "./chunk-WJJV5OTW.js";
import "./chunk-OL3AADLO.js";

// node_modules/topojson/node_modules/topojson-client/src/identity.js
function identity_default(x) {
  return x;
}

// node_modules/topojson/node_modules/topojson-client/src/transform.js
function transform_default2(transform) {
  if (transform == null)
    return identity_default;
  var x0, y0, kx = transform.scale[0], ky = transform.scale[1], dx = transform.translate[0], dy = transform.translate[1];
  return function(input, i) {
    if (!i)
      x0 = y0 = 0;
    var j = 2, n = input.length, output = new Array(n);
    output[0] = (x0 += input[0]) * kx + dx;
    output[1] = (y0 += input[1]) * ky + dy;
    while (j < n)
      output[j] = input[j], ++j;
    return output;
  };
}

// node_modules/topojson/node_modules/topojson-client/src/bbox.js
function bbox_default(topology) {
  var t = transform_default2(topology.transform), key, x0 = Infinity, y0 = x0, x1 = -x0, y1 = -x0;
  function bboxPoint(p) {
    p = t(p);
    if (p[0] < x0)
      x0 = p[0];
    if (p[0] > x1)
      x1 = p[0];
    if (p[1] < y0)
      y0 = p[1];
    if (p[1] > y1)
      y1 = p[1];
  }
  function bboxGeometry(o) {
    switch (o.type) {
      case "GeometryCollection":
        o.geometries.forEach(bboxGeometry);
        break;
      case "Point":
        bboxPoint(o.coordinates);
        break;
      case "MultiPoint":
        o.coordinates.forEach(bboxPoint);
        break;
    }
  }
  topology.arcs.forEach(function(arc) {
    var i = -1, n = arc.length, p;
    while (++i < n) {
      p = t(arc[i], i);
      if (p[0] < x0)
        x0 = p[0];
      if (p[0] > x1)
        x1 = p[0];
      if (p[1] < y0)
        y0 = p[1];
      if (p[1] > y1)
        y1 = p[1];
    }
  });
  for (key in topology.objects) {
    bboxGeometry(topology.objects[key]);
  }
  return [x0, y0, x1, y1];
}

// node_modules/topojson/node_modules/topojson-client/src/reverse.js
function reverse_default(array, n) {
  var t, j = array.length, i = j - n;
  while (i < --j)
    t = array[i], array[i++] = array[j], array[j] = t;
}

// node_modules/topojson/node_modules/topojson-client/src/feature.js
function feature_default2(topology, o) {
  return o.type === "GeometryCollection" ? { type: "FeatureCollection", features: o.geometries.map(function(o2) {
    return feature(topology, o2);
  }) } : feature(topology, o);
}
function feature(topology, o) {
  var id = o.id, bbox = o.bbox, properties = o.properties == null ? {} : o.properties, geometry = object(topology, o);
  return id == null && bbox == null ? { type: "Feature", properties, geometry } : bbox == null ? { type: "Feature", id, properties, geometry } : { type: "Feature", id, bbox, properties, geometry };
}
function object(topology, o) {
  var transformPoint = transform_default2(topology.transform), arcs = topology.arcs;
  function arc(i, points) {
    if (points.length)
      points.pop();
    for (var a = arcs[i < 0 ? ~i : i], k = 0, n = a.length; k < n; ++k) {
      points.push(transformPoint(a[k], k));
    }
    if (i < 0)
      reverse_default(points, n);
  }
  function point(p) {
    return transformPoint(p);
  }
  function line(arcs2) {
    var points = [];
    for (var i = 0, n = arcs2.length; i < n; ++i)
      arc(arcs2[i], points);
    if (points.length < 2)
      points.push(points[0]);
    return points;
  }
  function ring(arcs2) {
    var points = line(arcs2);
    while (points.length < 4)
      points.push(points[0]);
    return points;
  }
  function polygon(arcs2) {
    return arcs2.map(ring);
  }
  function geometry(o2) {
    var type = o2.type, coordinates;
    switch (type) {
      case "GeometryCollection":
        return { type, geometries: o2.geometries.map(geometry) };
      case "Point":
        coordinates = point(o2.coordinates);
        break;
      case "MultiPoint":
        coordinates = o2.coordinates.map(point);
        break;
      case "LineString":
        coordinates = line(o2.arcs);
        break;
      case "MultiLineString":
        coordinates = o2.arcs.map(line);
        break;
      case "Polygon":
        coordinates = polygon(o2.arcs);
        break;
      case "MultiPolygon":
        coordinates = o2.arcs.map(polygon);
        break;
      default:
        return null;
    }
    return { type, coordinates };
  }
  return geometry(o);
}

// node_modules/topojson/node_modules/topojson-client/src/stitch.js
function stitch_default(topology, arcs) {
  var stitchedArcs = {}, fragmentByStart = {}, fragmentByEnd = {}, fragments = [], emptyIndex = -1;
  arcs.forEach(function(i, j) {
    var arc = topology.arcs[i < 0 ? ~i : i], t;
    if (arc.length < 3 && !arc[1][0] && !arc[1][1]) {
      t = arcs[++emptyIndex], arcs[emptyIndex] = i, arcs[j] = t;
    }
  });
  arcs.forEach(function(i) {
    var e = ends(i), start = e[0], end = e[1], f, g;
    if (f = fragmentByEnd[start]) {
      delete fragmentByEnd[f.end];
      f.push(i);
      f.end = end;
      if (g = fragmentByStart[end]) {
        delete fragmentByStart[g.start];
        var fg = g === f ? f : f.concat(g);
        fragmentByStart[fg.start = f.start] = fragmentByEnd[fg.end = g.end] = fg;
      } else {
        fragmentByStart[f.start] = fragmentByEnd[f.end] = f;
      }
    } else if (f = fragmentByStart[end]) {
      delete fragmentByStart[f.start];
      f.unshift(i);
      f.start = start;
      if (g = fragmentByEnd[start]) {
        delete fragmentByEnd[g.end];
        var gf = g === f ? f : g.concat(f);
        fragmentByStart[gf.start = g.start] = fragmentByEnd[gf.end = f.end] = gf;
      } else {
        fragmentByStart[f.start] = fragmentByEnd[f.end] = f;
      }
    } else {
      f = [i];
      fragmentByStart[f.start = start] = fragmentByEnd[f.end = end] = f;
    }
  });
  function ends(i) {
    var arc = topology.arcs[i < 0 ? ~i : i], p0 = arc[0], p1;
    if (topology.transform)
      p1 = [0, 0], arc.forEach(function(dp) {
        p1[0] += dp[0], p1[1] += dp[1];
      });
    else
      p1 = arc[arc.length - 1];
    return i < 0 ? [p1, p0] : [p0, p1];
  }
  function flush(fragmentByEnd2, fragmentByStart2) {
    for (var k in fragmentByEnd2) {
      var f = fragmentByEnd2[k];
      delete fragmentByStart2[f.start];
      delete f.start;
      delete f.end;
      f.forEach(function(i) {
        stitchedArcs[i < 0 ? ~i : i] = 1;
      });
      fragments.push(f);
    }
  }
  flush(fragmentByEnd, fragmentByStart);
  flush(fragmentByStart, fragmentByEnd);
  arcs.forEach(function(i) {
    if (!stitchedArcs[i < 0 ? ~i : i])
      fragments.push([i]);
  });
  return fragments;
}

// node_modules/topojson/node_modules/topojson-client/src/mesh.js
function mesh_default(topology) {
  return object(topology, meshArcs.apply(this, arguments));
}
function meshArcs(topology, object2, filter) {
  var arcs, i, n;
  if (arguments.length > 1)
    arcs = extractArcs(topology, object2, filter);
  else
    for (i = 0, arcs = new Array(n = topology.arcs.length); i < n; ++i)
      arcs[i] = i;
  return { type: "MultiLineString", arcs: stitch_default(topology, arcs) };
}
function extractArcs(topology, object2, filter) {
  var arcs = [], geomsByArc = [], geom;
  function extract0(i) {
    var j = i < 0 ? ~i : i;
    (geomsByArc[j] || (geomsByArc[j] = [])).push({ i, g: geom });
  }
  function extract1(arcs2) {
    arcs2.forEach(extract0);
  }
  function extract2(arcs2) {
    arcs2.forEach(extract1);
  }
  function extract3(arcs2) {
    arcs2.forEach(extract2);
  }
  function geometry(o) {
    switch (geom = o, o.type) {
      case "GeometryCollection":
        o.geometries.forEach(geometry);
        break;
      case "LineString":
        extract1(o.arcs);
        break;
      case "MultiLineString":
      case "Polygon":
        extract2(o.arcs);
        break;
      case "MultiPolygon":
        extract3(o.arcs);
        break;
    }
  }
  geometry(object2);
  geomsByArc.forEach(filter == null ? function(geoms) {
    arcs.push(geoms[0].i);
  } : function(geoms) {
    if (filter(geoms[0].g, geoms[geoms.length - 1].g))
      arcs.push(geoms[0].i);
  });
  return arcs;
}

// node_modules/topojson/node_modules/topojson-client/src/merge.js
function planarRingArea(ring) {
  var i = -1, n = ring.length, a, b = ring[n - 1], area = 0;
  while (++i < n)
    a = b, b = ring[i], area += a[0] * b[1] - a[1] * b[0];
  return Math.abs(area);
}
function merge_default(topology) {
  return object(topology, mergeArcs.apply(this, arguments));
}
function mergeArcs(topology, objects) {
  var polygonsByArc = {}, polygons = [], groups = [];
  objects.forEach(geometry);
  function geometry(o) {
    switch (o.type) {
      case "GeometryCollection":
        o.geometries.forEach(geometry);
        break;
      case "Polygon":
        extract(o.arcs);
        break;
      case "MultiPolygon":
        o.arcs.forEach(extract);
        break;
    }
  }
  function extract(polygon) {
    polygon.forEach(function(ring) {
      ring.forEach(function(arc) {
        (polygonsByArc[arc = arc < 0 ? ~arc : arc] || (polygonsByArc[arc] = [])).push(polygon);
      });
    });
    polygons.push(polygon);
  }
  function area(ring) {
    return planarRingArea(object(topology, { type: "Polygon", arcs: [ring] }).coordinates[0]);
  }
  polygons.forEach(function(polygon) {
    if (!polygon._) {
      var group = [], neighbors = [polygon];
      polygon._ = 1;
      groups.push(group);
      while (polygon = neighbors.pop()) {
        group.push(polygon);
        polygon.forEach(function(ring) {
          ring.forEach(function(arc) {
            polygonsByArc[arc < 0 ? ~arc : arc].forEach(function(polygon2) {
              if (!polygon2._) {
                polygon2._ = 1;
                neighbors.push(polygon2);
              }
            });
          });
        });
      }
    }
  });
  polygons.forEach(function(polygon) {
    delete polygon._;
  });
  return {
    type: "MultiPolygon",
    arcs: groups.map(function(polygons2) {
      var arcs = [], n;
      polygons2.forEach(function(polygon) {
        polygon.forEach(function(ring) {
          ring.forEach(function(arc) {
            if (polygonsByArc[arc < 0 ? ~arc : arc].length < 2) {
              arcs.push(arc);
            }
          });
        });
      });
      arcs = stitch_default(topology, arcs);
      if ((n = arcs.length) > 1) {
        for (var i = 1, k = area(arcs[0]), ki, t; i < n; ++i) {
          if ((ki = area(arcs[i])) > k) {
            t = arcs[0], arcs[0] = arcs[i], arcs[i] = t, k = ki;
          }
        }
      }
      return arcs;
    })
  };
}

// node_modules/topojson/node_modules/topojson-client/src/bisect.js
function bisect_default(a, x) {
  var lo = 0, hi = a.length;
  while (lo < hi) {
    var mid = lo + hi >>> 1;
    if (a[mid] < x)
      lo = mid + 1;
    else
      hi = mid;
  }
  return lo;
}

// node_modules/topojson/node_modules/topojson-client/src/neighbors.js
function neighbors_default(objects) {
  var indexesByArc = {}, neighbors = objects.map(function() {
    return [];
  });
  function line(arcs, i2) {
    arcs.forEach(function(a) {
      if (a < 0)
        a = ~a;
      var o = indexesByArc[a];
      if (o)
        o.push(i2);
      else
        indexesByArc[a] = [i2];
    });
  }
  function polygon(arcs, i2) {
    arcs.forEach(function(arc) {
      line(arc, i2);
    });
  }
  function geometry(o, i2) {
    if (o.type === "GeometryCollection")
      o.geometries.forEach(function(o2) {
        geometry(o2, i2);
      });
    else if (o.type in geometryType)
      geometryType[o.type](o.arcs, i2);
  }
  var geometryType = {
    LineString: line,
    MultiLineString: polygon,
    Polygon: polygon,
    MultiPolygon: function(arcs, i2) {
      arcs.forEach(function(arc) {
        polygon(arc, i2);
      });
    }
  };
  objects.forEach(geometry);
  for (var i in indexesByArc) {
    for (var indexes = indexesByArc[i], m = indexes.length, j = 0; j < m; ++j) {
      for (var k = j + 1; k < m; ++k) {
        var ij = indexes[j], ik = indexes[k], n;
        if ((n = neighbors[ij])[i = bisect_default(n, ik)] !== ik)
          n.splice(i, 0, ik);
        if ((n = neighbors[ik])[i = bisect_default(n, ij)] !== ij)
          n.splice(i, 0, ij);
      }
    }
  }
  return neighbors;
}

// node_modules/topojson/node_modules/topojson-client/src/untransform.js
function untransform_default(transform) {
  if (transform == null)
    return identity_default;
  var x0, y0, kx = transform.scale[0], ky = transform.scale[1], dx = transform.translate[0], dy = transform.translate[1];
  return function(input, i) {
    if (!i)
      x0 = y0 = 0;
    var j = 2, n = input.length, output = new Array(n), x1 = Math.round((input[0] - dx) / kx), y1 = Math.round((input[1] - dy) / ky);
    output[0] = x1 - x0, x0 = x1;
    output[1] = y1 - y0, y0 = y1;
    while (j < n)
      output[j] = input[j], ++j;
    return output;
  };
}

// node_modules/topojson/node_modules/topojson-client/src/quantize.js
function quantize_default(topology, transform) {
  if (topology.transform)
    throw new Error("already quantized");
  if (!transform || !transform.scale) {
    if (!((n = Math.floor(transform)) >= 2))
      throw new Error("n must be \u22652");
    box = topology.bbox || bbox_default(topology);
    var x0 = box[0], y0 = box[1], x1 = box[2], y1 = box[3], n;
    transform = { scale: [x1 - x0 ? (x1 - x0) / (n - 1) : 1, y1 - y0 ? (y1 - y0) / (n - 1) : 1], translate: [x0, y0] };
  } else {
    box = topology.bbox;
  }
  var t = untransform_default(transform), box, key, inputs = topology.objects, outputs = {};
  function quantizePoint(point) {
    return t(point);
  }
  function quantizeGeometry(input) {
    var output;
    switch (input.type) {
      case "GeometryCollection":
        output = { type: "GeometryCollection", geometries: input.geometries.map(quantizeGeometry) };
        break;
      case "Point":
        output = { type: "Point", coordinates: quantizePoint(input.coordinates) };
        break;
      case "MultiPoint":
        output = { type: "MultiPoint", coordinates: input.coordinates.map(quantizePoint) };
        break;
      default:
        return input;
    }
    if (input.id != null)
      output.id = input.id;
    if (input.bbox != null)
      output.bbox = input.bbox;
    if (input.properties != null)
      output.properties = input.properties;
    return output;
  }
  function quantizeArc(input) {
    var i = 0, j = 1, n2 = input.length, p, output = new Array(n2);
    output[0] = t(input[0], 0);
    while (++i < n2)
      if ((p = t(input[i], i))[0] || p[1])
        output[j++] = p;
    if (j === 1)
      output[j++] = [0, 0];
    output.length = j;
    return output;
  }
  for (key in inputs)
    outputs[key] = quantizeGeometry(inputs[key]);
  return {
    type: "Topology",
    bbox: box,
    transform,
    objects: outputs,
    arcs: topology.arcs.map(quantizeArc)
  };
}

// node_modules/topojson-server/src/bounds.js
function bounds_default(objects) {
  var x0 = Infinity, y0 = Infinity, x1 = -Infinity, y1 = -Infinity;
  function boundGeometry(geometry) {
    if (geometry != null && boundGeometryType.hasOwnProperty(geometry.type))
      boundGeometryType[geometry.type](geometry);
  }
  var boundGeometryType = {
    GeometryCollection: function(o) {
      o.geometries.forEach(boundGeometry);
    },
    Point: function(o) {
      boundPoint(o.coordinates);
    },
    MultiPoint: function(o) {
      o.coordinates.forEach(boundPoint);
    },
    LineString: function(o) {
      boundLine(o.arcs);
    },
    MultiLineString: function(o) {
      o.arcs.forEach(boundLine);
    },
    Polygon: function(o) {
      o.arcs.forEach(boundLine);
    },
    MultiPolygon: function(o) {
      o.arcs.forEach(boundMultiLine);
    }
  };
  function boundPoint(coordinates) {
    var x = coordinates[0], y = coordinates[1];
    if (x < x0)
      x0 = x;
    if (x > x1)
      x1 = x;
    if (y < y0)
      y0 = y;
    if (y > y1)
      y1 = y;
  }
  function boundLine(coordinates) {
    coordinates.forEach(boundPoint);
  }
  function boundMultiLine(coordinates) {
    coordinates.forEach(boundLine);
  }
  for (var key in objects) {
    boundGeometry(objects[key]);
  }
  return x1 >= x0 && y1 >= y0 ? [x0, y0, x1, y1] : void 0;
}

// node_modules/topojson-server/src/hash/hashset.js
function hashset_default(size, hash, equal, type, empty) {
  if (arguments.length === 3) {
    type = Array;
    empty = null;
  }
  var store = new type(size = 1 << Math.max(4, Math.ceil(Math.log(size) / Math.LN2))), mask = size - 1;
  for (var i = 0; i < size; ++i) {
    store[i] = empty;
  }
  function add(value) {
    var index = hash(value) & mask, match = store[index], collisions = 0;
    while (match != empty) {
      if (equal(match, value))
        return true;
      if (++collisions >= size)
        throw new Error("full hashset");
      match = store[index = index + 1 & mask];
    }
    store[index] = value;
    return true;
  }
  function has(value) {
    var index = hash(value) & mask, match = store[index], collisions = 0;
    while (match != empty) {
      if (equal(match, value))
        return true;
      if (++collisions >= size)
        break;
      match = store[index = index + 1 & mask];
    }
    return false;
  }
  function values() {
    var values2 = [];
    for (var i2 = 0, n = store.length; i2 < n; ++i2) {
      var match = store[i2];
      if (match != empty)
        values2.push(match);
    }
    return values2;
  }
  return {
    add,
    has,
    values
  };
}

// node_modules/topojson-server/src/hash/hashmap.js
function hashmap_default(size, hash, equal, keyType, keyEmpty, valueType) {
  if (arguments.length === 3) {
    keyType = valueType = Array;
    keyEmpty = null;
  }
  var keystore = new keyType(size = 1 << Math.max(4, Math.ceil(Math.log(size) / Math.LN2))), valstore = new valueType(size), mask = size - 1;
  for (var i = 0; i < size; ++i) {
    keystore[i] = keyEmpty;
  }
  function set(key, value) {
    var index = hash(key) & mask, matchKey = keystore[index], collisions = 0;
    while (matchKey != keyEmpty) {
      if (equal(matchKey, key))
        return valstore[index] = value;
      if (++collisions >= size)
        throw new Error("full hashmap");
      matchKey = keystore[index = index + 1 & mask];
    }
    keystore[index] = key;
    valstore[index] = value;
    return value;
  }
  function maybeSet(key, value) {
    var index = hash(key) & mask, matchKey = keystore[index], collisions = 0;
    while (matchKey != keyEmpty) {
      if (equal(matchKey, key))
        return valstore[index];
      if (++collisions >= size)
        throw new Error("full hashmap");
      matchKey = keystore[index = index + 1 & mask];
    }
    keystore[index] = key;
    valstore[index] = value;
    return value;
  }
  function get(key, missingValue) {
    var index = hash(key) & mask, matchKey = keystore[index], collisions = 0;
    while (matchKey != keyEmpty) {
      if (equal(matchKey, key))
        return valstore[index];
      if (++collisions >= size)
        break;
      matchKey = keystore[index = index + 1 & mask];
    }
    return missingValue;
  }
  function keys() {
    var keys2 = [];
    for (var i2 = 0, n = keystore.length; i2 < n; ++i2) {
      var matchKey = keystore[i2];
      if (matchKey != keyEmpty)
        keys2.push(matchKey);
    }
    return keys2;
  }
  return {
    set,
    maybeSet,
    get,
    keys
  };
}

// node_modules/topojson-server/src/hash/point-equal.js
function point_equal_default(pointA, pointB) {
  return pointA[0] === pointB[0] && pointA[1] === pointB[1];
}

// node_modules/topojson-server/src/hash/point-hash.js
var buffer = new ArrayBuffer(16);
var floats = new Float64Array(buffer);
var uints = new Uint32Array(buffer);
function point_hash_default(point) {
  floats[0] = point[0];
  floats[1] = point[1];
  var hash = uints[0] ^ uints[1];
  hash = hash << 5 ^ hash >> 7 ^ uints[2] ^ uints[3];
  return hash & 2147483647;
}

// node_modules/topojson-server/src/join.js
function join_default(topology) {
  var coordinates = topology.coordinates, lines = topology.lines, rings = topology.rings, indexes = index(), visitedByIndex = new Int32Array(coordinates.length), leftByIndex = new Int32Array(coordinates.length), rightByIndex = new Int32Array(coordinates.length), junctionByIndex = new Int8Array(coordinates.length), junctionCount = 0, i, n, previousIndex, currentIndex, nextIndex;
  for (i = 0, n = coordinates.length; i < n; ++i) {
    visitedByIndex[i] = leftByIndex[i] = rightByIndex[i] = -1;
  }
  for (i = 0, n = lines.length; i < n; ++i) {
    var line = lines[i], lineStart = line[0], lineEnd = line[1];
    currentIndex = indexes[lineStart];
    nextIndex = indexes[++lineStart];
    ++junctionCount, junctionByIndex[currentIndex] = 1;
    while (++lineStart <= lineEnd) {
      sequence(i, previousIndex = currentIndex, currentIndex = nextIndex, nextIndex = indexes[lineStart]);
    }
    ++junctionCount, junctionByIndex[nextIndex] = 1;
  }
  for (i = 0, n = coordinates.length; i < n; ++i) {
    visitedByIndex[i] = -1;
  }
  for (i = 0, n = rings.length; i < n; ++i) {
    var ring = rings[i], ringStart = ring[0] + 1, ringEnd = ring[1];
    previousIndex = indexes[ringEnd - 1];
    currentIndex = indexes[ringStart - 1];
    nextIndex = indexes[ringStart];
    sequence(i, previousIndex, currentIndex, nextIndex);
    while (++ringStart <= ringEnd) {
      sequence(i, previousIndex = currentIndex, currentIndex = nextIndex, nextIndex = indexes[ringStart]);
    }
  }
  function sequence(i2, previousIndex2, currentIndex2, nextIndex2) {
    if (visitedByIndex[currentIndex2] === i2)
      return;
    visitedByIndex[currentIndex2] = i2;
    var leftIndex = leftByIndex[currentIndex2];
    if (leftIndex >= 0) {
      var rightIndex = rightByIndex[currentIndex2];
      if ((leftIndex !== previousIndex2 || rightIndex !== nextIndex2) && (leftIndex !== nextIndex2 || rightIndex !== previousIndex2)) {
        ++junctionCount, junctionByIndex[currentIndex2] = 1;
      }
    } else {
      leftByIndex[currentIndex2] = previousIndex2;
      rightByIndex[currentIndex2] = nextIndex2;
    }
  }
  function index() {
    var indexByPoint = hashmap_default(coordinates.length * 1.4, hashIndex, equalIndex, Int32Array, -1, Int32Array), indexes2 = new Int32Array(coordinates.length);
    for (var i2 = 0, n2 = coordinates.length; i2 < n2; ++i2) {
      indexes2[i2] = indexByPoint.maybeSet(i2, i2);
    }
    return indexes2;
  }
  function hashIndex(i2) {
    return point_hash_default(coordinates[i2]);
  }
  function equalIndex(i2, j2) {
    return point_equal_default(coordinates[i2], coordinates[j2]);
  }
  visitedByIndex = leftByIndex = rightByIndex = null;
  var junctionByPoint = hashset_default(junctionCount * 1.4, point_hash_default, point_equal_default), j;
  for (i = 0, n = coordinates.length; i < n; ++i) {
    if (junctionByIndex[j = indexes[i]]) {
      junctionByPoint.add(coordinates[j]);
    }
  }
  return junctionByPoint;
}

// node_modules/topojson-server/src/cut.js
function cut_default(topology) {
  var junctions = join_default(topology), coordinates = topology.coordinates, lines = topology.lines, rings = topology.rings, next, i, n;
  for (i = 0, n = lines.length; i < n; ++i) {
    var line = lines[i], lineMid = line[0], lineEnd = line[1];
    while (++lineMid < lineEnd) {
      if (junctions.has(coordinates[lineMid])) {
        next = { 0: lineMid, 1: line[1] };
        line[1] = lineMid;
        line = line.next = next;
      }
    }
  }
  for (i = 0, n = rings.length; i < n; ++i) {
    var ring = rings[i], ringStart = ring[0], ringMid = ringStart, ringEnd = ring[1], ringFixed = junctions.has(coordinates[ringStart]);
    while (++ringMid < ringEnd) {
      if (junctions.has(coordinates[ringMid])) {
        if (ringFixed) {
          next = { 0: ringMid, 1: ring[1] };
          ring[1] = ringMid;
          ring = ring.next = next;
        } else {
          rotateArray(coordinates, ringStart, ringEnd, ringEnd - ringMid);
          coordinates[ringEnd] = coordinates[ringStart];
          ringFixed = true;
          ringMid = ringStart;
        }
      }
    }
  }
  return topology;
}
function rotateArray(array, start, end, offset) {
  reverse(array, start, end);
  reverse(array, start, start + offset);
  reverse(array, start + offset, end);
}
function reverse(array, start, end) {
  for (var mid = start + (end-- - start >> 1), t; start < mid; ++start, --end) {
    t = array[start], array[start] = array[end], array[end] = t;
  }
}

// node_modules/topojson-server/src/dedup.js
function dedup_default(topology) {
  var coordinates = topology.coordinates, lines = topology.lines, line, rings = topology.rings, ring, arcCount = lines.length + rings.length, i, n;
  delete topology.lines;
  delete topology.rings;
  for (i = 0, n = lines.length; i < n; ++i) {
    line = lines[i];
    while (line = line.next)
      ++arcCount;
  }
  for (i = 0, n = rings.length; i < n; ++i) {
    ring = rings[i];
    while (ring = ring.next)
      ++arcCount;
  }
  var arcsByEnd = hashmap_default(arcCount * 2 * 1.4, point_hash_default, point_equal_default), arcs = topology.arcs = [];
  for (i = 0, n = lines.length; i < n; ++i) {
    line = lines[i];
    do {
      dedupLine(line);
    } while (line = line.next);
  }
  for (i = 0, n = rings.length; i < n; ++i) {
    ring = rings[i];
    if (ring.next) {
      do {
        dedupLine(ring);
      } while (ring = ring.next);
    } else {
      dedupRing(ring);
    }
  }
  function dedupLine(arc) {
    var startPoint, endPoint, startArcs, startArc, endArcs, endArc, i2, n2;
    if (startArcs = arcsByEnd.get(startPoint = coordinates[arc[0]])) {
      for (i2 = 0, n2 = startArcs.length; i2 < n2; ++i2) {
        startArc = startArcs[i2];
        if (equalLine(startArc, arc)) {
          arc[0] = startArc[0];
          arc[1] = startArc[1];
          return;
        }
      }
    }
    if (endArcs = arcsByEnd.get(endPoint = coordinates[arc[1]])) {
      for (i2 = 0, n2 = endArcs.length; i2 < n2; ++i2) {
        endArc = endArcs[i2];
        if (reverseEqualLine(endArc, arc)) {
          arc[1] = endArc[0];
          arc[0] = endArc[1];
          return;
        }
      }
    }
    if (startArcs)
      startArcs.push(arc);
    else
      arcsByEnd.set(startPoint, [arc]);
    if (endArcs)
      endArcs.push(arc);
    else
      arcsByEnd.set(endPoint, [arc]);
    arcs.push(arc);
  }
  function dedupRing(arc) {
    var endPoint, endArcs, endArc, i2, n2;
    if (endArcs = arcsByEnd.get(endPoint = coordinates[arc[0]])) {
      for (i2 = 0, n2 = endArcs.length; i2 < n2; ++i2) {
        endArc = endArcs[i2];
        if (equalRing(endArc, arc)) {
          arc[0] = endArc[0];
          arc[1] = endArc[1];
          return;
        }
        if (reverseEqualRing(endArc, arc)) {
          arc[0] = endArc[1];
          arc[1] = endArc[0];
          return;
        }
      }
    }
    if (endArcs = arcsByEnd.get(endPoint = coordinates[arc[0] + findMinimumOffset(arc)])) {
      for (i2 = 0, n2 = endArcs.length; i2 < n2; ++i2) {
        endArc = endArcs[i2];
        if (equalRing(endArc, arc)) {
          arc[0] = endArc[0];
          arc[1] = endArc[1];
          return;
        }
        if (reverseEqualRing(endArc, arc)) {
          arc[0] = endArc[1];
          arc[1] = endArc[0];
          return;
        }
      }
    }
    if (endArcs)
      endArcs.push(arc);
    else
      arcsByEnd.set(endPoint, [arc]);
    arcs.push(arc);
  }
  function equalLine(arcA, arcB) {
    var ia = arcA[0], ib = arcB[0], ja = arcA[1], jb = arcB[1];
    if (ia - ja !== ib - jb)
      return false;
    for (; ia <= ja; ++ia, ++ib)
      if (!point_equal_default(coordinates[ia], coordinates[ib]))
        return false;
    return true;
  }
  function reverseEqualLine(arcA, arcB) {
    var ia = arcA[0], ib = arcB[0], ja = arcA[1], jb = arcB[1];
    if (ia - ja !== ib - jb)
      return false;
    for (; ia <= ja; ++ia, --jb)
      if (!point_equal_default(coordinates[ia], coordinates[jb]))
        return false;
    return true;
  }
  function equalRing(arcA, arcB) {
    var ia = arcA[0], ib = arcB[0], ja = arcA[1], jb = arcB[1], n2 = ja - ia;
    if (n2 !== jb - ib)
      return false;
    var ka = findMinimumOffset(arcA), kb = findMinimumOffset(arcB);
    for (var i2 = 0; i2 < n2; ++i2) {
      if (!point_equal_default(coordinates[ia + (i2 + ka) % n2], coordinates[ib + (i2 + kb) % n2]))
        return false;
    }
    return true;
  }
  function reverseEqualRing(arcA, arcB) {
    var ia = arcA[0], ib = arcB[0], ja = arcA[1], jb = arcB[1], n2 = ja - ia;
    if (n2 !== jb - ib)
      return false;
    var ka = findMinimumOffset(arcA), kb = n2 - findMinimumOffset(arcB);
    for (var i2 = 0; i2 < n2; ++i2) {
      if (!point_equal_default(coordinates[ia + (i2 + ka) % n2], coordinates[jb - (i2 + kb) % n2]))
        return false;
    }
    return true;
  }
  function findMinimumOffset(arc) {
    var start = arc[0], end = arc[1], mid = start, minimum = mid, minimumPoint = coordinates[mid];
    while (++mid < end) {
      var point = coordinates[mid];
      if (point[0] < minimumPoint[0] || point[0] === minimumPoint[0] && point[1] < minimumPoint[1]) {
        minimum = mid;
        minimumPoint = point;
      }
    }
    return minimum - start;
  }
  return topology;
}

// node_modules/topojson-server/src/delta.js
function delta_default(arcs) {
  var i = -1, n = arcs.length;
  while (++i < n) {
    var arc = arcs[i], j = 0, k = 1, m = arc.length, point = arc[0], x0 = point[0], y0 = point[1], x1, y1;
    while (++j < m) {
      point = arc[j], x1 = point[0], y1 = point[1];
      if (x1 !== x0 || y1 !== y0)
        arc[k++] = [x1 - x0, y1 - y0], x0 = x1, y0 = y1;
    }
    if (k === 1)
      arc[k++] = [0, 0];
    arc.length = k;
  }
  return arcs;
}

// node_modules/topojson-server/src/extract.js
function extract_default(objects) {
  var index = -1, lines = [], rings = [], coordinates = [];
  function extractGeometry(geometry) {
    if (geometry && extractGeometryType.hasOwnProperty(geometry.type))
      extractGeometryType[geometry.type](geometry);
  }
  var extractGeometryType = {
    GeometryCollection: function(o) {
      o.geometries.forEach(extractGeometry);
    },
    LineString: function(o) {
      o.arcs = extractLine(o.arcs);
    },
    MultiLineString: function(o) {
      o.arcs = o.arcs.map(extractLine);
    },
    Polygon: function(o) {
      o.arcs = o.arcs.map(extractRing);
    },
    MultiPolygon: function(o) {
      o.arcs = o.arcs.map(extractMultiRing);
    }
  };
  function extractLine(line) {
    for (var i = 0, n = line.length; i < n; ++i)
      coordinates[++index] = line[i];
    var arc = { 0: index - n + 1, 1: index };
    lines.push(arc);
    return arc;
  }
  function extractRing(ring) {
    for (var i = 0, n = ring.length; i < n; ++i)
      coordinates[++index] = ring[i];
    var arc = { 0: index - n + 1, 1: index };
    rings.push(arc);
    return arc;
  }
  function extractMultiRing(rings2) {
    return rings2.map(extractRing);
  }
  for (var key in objects) {
    extractGeometry(objects[key]);
  }
  return {
    type: "Topology",
    coordinates,
    lines,
    rings,
    objects
  };
}

// node_modules/topojson-server/src/geometry.js
function geometry_default(inputs) {
  var outputs = {}, key;
  for (key in inputs)
    outputs[key] = geomifyObject(inputs[key]);
  return outputs;
}
function geomifyObject(input) {
  return input == null ? { type: null } : (input.type === "FeatureCollection" ? geomifyFeatureCollection : input.type === "Feature" ? geomifyFeature : geomifyGeometry)(input);
}
function geomifyFeatureCollection(input) {
  var output = { type: "GeometryCollection", geometries: input.features.map(geomifyFeature) };
  if (input.bbox != null)
    output.bbox = input.bbox;
  return output;
}
function geomifyFeature(input) {
  var output = geomifyGeometry(input.geometry), key;
  if (input.id != null)
    output.id = input.id;
  if (input.bbox != null)
    output.bbox = input.bbox;
  for (key in input.properties) {
    output.properties = input.properties;
    break;
  }
  return output;
}
function geomifyGeometry(input) {
  if (input == null)
    return { type: null };
  var output = input.type === "GeometryCollection" ? { type: "GeometryCollection", geometries: input.geometries.map(geomifyGeometry) } : input.type === "Point" || input.type === "MultiPoint" ? { type: input.type, coordinates: input.coordinates } : { type: input.type, arcs: input.coordinates };
  if (input.bbox != null)
    output.bbox = input.bbox;
  return output;
}

// node_modules/topojson-server/src/prequantize.js
function prequantize_default(objects, bbox, n) {
  var x0 = bbox[0], y0 = bbox[1], x1 = bbox[2], y1 = bbox[3], kx = x1 - x0 ? (n - 1) / (x1 - x0) : 1, ky = y1 - y0 ? (n - 1) / (y1 - y0) : 1;
  function quantizePoint(input) {
    return [Math.round((input[0] - x0) * kx), Math.round((input[1] - y0) * ky)];
  }
  function quantizePoints(input, m) {
    var i = -1, j = 0, n2 = input.length, output = new Array(n2), pi2, px, py, x, y;
    while (++i < n2) {
      pi2 = input[i];
      x = Math.round((pi2[0] - x0) * kx);
      y = Math.round((pi2[1] - y0) * ky);
      if (x !== px || y !== py)
        output[j++] = [px = x, py = y];
    }
    output.length = j;
    while (j < m)
      j = output.push([output[0][0], output[0][1]]);
    return output;
  }
  function quantizeLine(input) {
    return quantizePoints(input, 2);
  }
  function quantizeRing(input) {
    return quantizePoints(input, 4);
  }
  function quantizePolygon(input) {
    return input.map(quantizeRing);
  }
  function quantizeGeometry(o) {
    if (o != null && quantizeGeometryType.hasOwnProperty(o.type))
      quantizeGeometryType[o.type](o);
  }
  var quantizeGeometryType = {
    GeometryCollection: function(o) {
      o.geometries.forEach(quantizeGeometry);
    },
    Point: function(o) {
      o.coordinates = quantizePoint(o.coordinates);
    },
    MultiPoint: function(o) {
      o.coordinates = o.coordinates.map(quantizePoint);
    },
    LineString: function(o) {
      o.arcs = quantizeLine(o.arcs);
    },
    MultiLineString: function(o) {
      o.arcs = o.arcs.map(quantizeLine);
    },
    Polygon: function(o) {
      o.arcs = quantizePolygon(o.arcs);
    },
    MultiPolygon: function(o) {
      o.arcs = o.arcs.map(quantizePolygon);
    }
  };
  for (var key in objects) {
    quantizeGeometry(objects[key]);
  }
  return {
    scale: [1 / kx, 1 / ky],
    translate: [x0, y0]
  };
}

// node_modules/topojson-server/src/topology.js
function topology_default(objects, quantization) {
  var bbox = bounds_default(objects = geometry_default(objects)), transform = quantization > 0 && bbox && prequantize_default(objects, bbox, quantization), topology = dedup_default(cut_default(extract_default(objects))), coordinates = topology.coordinates, indexByArc = hashmap_default(topology.arcs.length * 1.4, hashArc, equalArc);
  objects = topology.objects;
  topology.bbox = bbox;
  topology.arcs = topology.arcs.map(function(arc, i) {
    indexByArc.set(arc, i);
    return coordinates.slice(arc[0], arc[1] + 1);
  });
  delete topology.coordinates;
  coordinates = null;
  function indexGeometry(geometry) {
    if (geometry && indexGeometryType.hasOwnProperty(geometry.type))
      indexGeometryType[geometry.type](geometry);
  }
  var indexGeometryType = {
    GeometryCollection: function(o) {
      o.geometries.forEach(indexGeometry);
    },
    LineString: function(o) {
      o.arcs = indexArcs(o.arcs);
    },
    MultiLineString: function(o) {
      o.arcs = o.arcs.map(indexArcs);
    },
    Polygon: function(o) {
      o.arcs = o.arcs.map(indexArcs);
    },
    MultiPolygon: function(o) {
      o.arcs = o.arcs.map(indexMultiArcs);
    }
  };
  function indexArcs(arc) {
    var indexes = [];
    do {
      var index = indexByArc.get(arc);
      indexes.push(arc[0] < arc[1] ? index : ~index);
    } while (arc = arc.next);
    return indexes;
  }
  function indexMultiArcs(arcs) {
    return arcs.map(indexArcs);
  }
  for (var key in objects) {
    indexGeometry(objects[key]);
  }
  if (transform) {
    topology.transform = transform;
    topology.arcs = delta_default(topology.arcs);
  }
  return topology;
}
function hashArc(arc) {
  var i = arc[0], j = arc[1], t;
  if (j < i)
    t = i, i = j, j = t;
  return i + 31 * j;
}
function equalArc(arcA, arcB) {
  var ia = arcA[0], ja = arcA[1], ib = arcB[0], jb = arcB[1], t;
  if (ja < ia)
    t = ia, ia = ja, ja = t;
  if (jb < ib)
    t = ib, ib = jb, jb = t;
  return ia === ib && ja === jb;
}

// node_modules/topojson-simplify/src/prune.js
function prune_default(topology) {
  var oldObjects = topology.objects, newObjects = {}, oldArcs = topology.arcs, oldArcsLength = oldArcs.length, oldIndex = -1, newIndexByOldIndex = new Array(oldArcsLength), newArcsLength = 0, newArcs, newIndex = -1, key;
  function scanGeometry(input) {
    switch (input.type) {
      case "GeometryCollection":
        input.geometries.forEach(scanGeometry);
        break;
      case "LineString":
        scanArcs(input.arcs);
        break;
      case "MultiLineString":
        input.arcs.forEach(scanArcs);
        break;
      case "Polygon":
        input.arcs.forEach(scanArcs);
        break;
      case "MultiPolygon":
        input.arcs.forEach(scanMultiArcs);
        break;
    }
  }
  function scanArc(index) {
    if (index < 0)
      index = ~index;
    if (!newIndexByOldIndex[index])
      newIndexByOldIndex[index] = 1, ++newArcsLength;
  }
  function scanArcs(arcs) {
    arcs.forEach(scanArc);
  }
  function scanMultiArcs(arcs) {
    arcs.forEach(scanArcs);
  }
  function reindexGeometry(input) {
    var output;
    switch (input.type) {
      case "GeometryCollection":
        output = { type: "GeometryCollection", geometries: input.geometries.map(reindexGeometry) };
        break;
      case "LineString":
        output = { type: "LineString", arcs: reindexArcs(input.arcs) };
        break;
      case "MultiLineString":
        output = { type: "MultiLineString", arcs: input.arcs.map(reindexArcs) };
        break;
      case "Polygon":
        output = { type: "Polygon", arcs: input.arcs.map(reindexArcs) };
        break;
      case "MultiPolygon":
        output = { type: "MultiPolygon", arcs: input.arcs.map(reindexMultiArcs) };
        break;
      default:
        return input;
    }
    if (input.id != null)
      output.id = input.id;
    if (input.bbox != null)
      output.bbox = input.bbox;
    if (input.properties != null)
      output.properties = input.properties;
    return output;
  }
  function reindexArc(oldIndex2) {
    return oldIndex2 < 0 ? ~newIndexByOldIndex[~oldIndex2] : newIndexByOldIndex[oldIndex2];
  }
  function reindexArcs(arcs) {
    return arcs.map(reindexArc);
  }
  function reindexMultiArcs(arcs) {
    return arcs.map(reindexArcs);
  }
  for (key in oldObjects) {
    scanGeometry(oldObjects[key]);
  }
  newArcs = new Array(newArcsLength);
  while (++oldIndex < oldArcsLength) {
    if (newIndexByOldIndex[oldIndex]) {
      newIndexByOldIndex[oldIndex] = ++newIndex;
      newArcs[newIndex] = oldArcs[oldIndex];
    }
  }
  for (key in oldObjects) {
    newObjects[key] = reindexGeometry(oldObjects[key]);
  }
  return {
    type: "Topology",
    bbox: topology.bbox,
    transform: topology.transform,
    objects: newObjects,
    arcs: newArcs
  };
}

// node_modules/topojson-simplify/src/filter.js
function filter_default(topology, filter) {
  var oldObjects = topology.objects, newObjects = {}, key;
  if (filter == null)
    filter = filterTrue;
  function filterGeometry(input) {
    var output, arcs;
    switch (input.type) {
      case "Polygon": {
        arcs = filterRings(input.arcs);
        output = arcs ? { type: "Polygon", arcs } : { type: null };
        break;
      }
      case "MultiPolygon": {
        arcs = input.arcs.map(filterRings).filter(filterIdentity);
        output = arcs.length ? { type: "MultiPolygon", arcs } : { type: null };
        break;
      }
      case "GeometryCollection": {
        arcs = input.geometries.map(filterGeometry).filter(filterNotNull);
        output = arcs.length ? { type: "GeometryCollection", geometries: arcs } : { type: null };
        break;
      }
      default:
        return input;
    }
    if (input.id != null)
      output.id = input.id;
    if (input.bbox != null)
      output.bbox = input.bbox;
    if (input.properties != null)
      output.properties = input.properties;
    return output;
  }
  function filterRings(arcs) {
    return arcs.length && filterExteriorRing(arcs[0]) ? [arcs[0]].concat(arcs.slice(1).filter(filterInteriorRing)) : null;
  }
  function filterExteriorRing(ring) {
    return filter(ring, false);
  }
  function filterInteriorRing(ring) {
    return filter(ring, true);
  }
  for (key in oldObjects) {
    newObjects[key] = filterGeometry(oldObjects[key]);
  }
  return prune_default({
    type: "Topology",
    bbox: topology.bbox,
    transform: topology.transform,
    objects: newObjects,
    arcs: topology.arcs
  });
}
function filterTrue() {
  return true;
}
function filterIdentity(x) {
  return x;
}
function filterNotNull(geometry) {
  return geometry.type != null;
}

// node_modules/topojson-simplify/src/filterAttached.js
function filterAttached_default(topology) {
  var ownerByArc = new Array(topology.arcs.length), ownerIndex = 0, key;
  function testGeometry(o) {
    switch (o.type) {
      case "GeometryCollection":
        o.geometries.forEach(testGeometry);
        break;
      case "Polygon":
        testArcs(o.arcs);
        break;
      case "MultiPolygon":
        o.arcs.forEach(testArcs);
        break;
    }
  }
  function testArcs(arcs) {
    for (var i = 0, n = arcs.length; i < n; ++i, ++ownerIndex) {
      for (var ring = arcs[i], j = 0, m = ring.length; j < m; ++j) {
        var arc = ring[j];
        if (arc < 0)
          arc = ~arc;
        var owner = ownerByArc[arc];
        if (owner == null)
          ownerByArc[arc] = ownerIndex;
        else if (owner !== ownerIndex)
          ownerByArc[arc] = -1;
      }
    }
  }
  for (key in topology.objects) {
    testGeometry(topology.objects[key]);
  }
  return function(ring) {
    for (var j = 0, m = ring.length, arc; j < m; ++j) {
      if (ownerByArc[(arc = ring[j]) < 0 ? ~arc : arc] === -1) {
        return true;
      }
    }
    return false;
  };
}

// node_modules/topojson-simplify/src/planar.js
function planarTriangleArea(triangle) {
  var a = triangle[0], b = triangle[1], c = triangle[2];
  return Math.abs((a[0] - c[0]) * (b[1] - a[1]) - (a[0] - b[0]) * (c[1] - a[1])) / 2;
}
function planarRingArea2(ring) {
  var i = -1, n = ring.length, a, b = ring[n - 1], area = 0;
  while (++i < n)
    a = b, b = ring[i], area += a[0] * b[1] - a[1] * b[0];
  return Math.abs(area) / 2;
}

// node_modules/topojson-simplify/src/filterWeight.js
function filterWeight_default(topology, minWeight, weight) {
  minWeight = minWeight == null ? Number.MIN_VALUE : +minWeight;
  if (weight == null)
    weight = planarRingArea2;
  return function(ring, interior) {
    return weight(feature_default(topology, { type: "Polygon", arcs: [ring] }).geometry.coordinates[0], interior) >= minWeight;
  };
}

// node_modules/topojson-simplify/src/filterAttachedWeight.js
function filterAttachedWeight_default(topology, minWeight, weight) {
  var a = filterAttached_default(topology), w = filterWeight_default(topology, minWeight, weight);
  return function(ring, interior) {
    return a(ring, interior) || w(ring, interior);
  };
}

// node_modules/topojson-simplify/src/heap.js
function compare(a, b) {
  return a[1][2] - b[1][2];
}
function heap_default() {
  var heap = {}, array = [], size = 0;
  heap.push = function(object2) {
    up(array[object2._ = size] = object2, size++);
    return size;
  };
  heap.pop = function() {
    if (size <= 0)
      return;
    var removed = array[0], object2;
    if (--size > 0)
      object2 = array[size], down(array[object2._ = 0] = object2, 0);
    return removed;
  };
  heap.remove = function(removed) {
    var i = removed._, object2;
    if (array[i] !== removed)
      return;
    if (i !== --size)
      object2 = array[size], (compare(object2, removed) < 0 ? up : down)(array[object2._ = i] = object2, i);
    return i;
  };
  function up(object2, i) {
    while (i > 0) {
      var j = (i + 1 >> 1) - 1, parent = array[j];
      if (compare(object2, parent) >= 0)
        break;
      array[parent._ = i] = parent;
      array[object2._ = i = j] = object2;
    }
  }
  function down(object2, i) {
    while (true) {
      var r = i + 1 << 1, l = r - 1, j = i, child = array[j];
      if (l < size && compare(array[l], child) < 0)
        child = array[j = l];
      if (r < size && compare(array[r], child) < 0)
        child = array[j = r];
      if (j === i)
        break;
      array[child._ = i] = child;
      array[object2._ = i = j] = object2;
    }
  }
  return heap;
}

// node_modules/topojson-simplify/src/presimplify.js
function copy(point) {
  return [point[0], point[1], 0];
}
function presimplify_default(topology, weight) {
  var point = topology.transform ? transform_default(topology.transform) : copy, heap = heap_default();
  if (weight == null)
    weight = planarTriangleArea;
  var arcs = topology.arcs.map(function(arc) {
    var triangles = [], maxWeight = 0, triangle, i, n;
    arc = arc.map(point);
    for (i = 1, n = arc.length - 1; i < n; ++i) {
      triangle = [arc[i - 1], arc[i], arc[i + 1]];
      triangle[1][2] = weight(triangle);
      triangles.push(triangle);
      heap.push(triangle);
    }
    arc[0][2] = arc[n][2] = Infinity;
    for (i = 0, n = triangles.length; i < n; ++i) {
      triangle = triangles[i];
      triangle.previous = triangles[i - 1];
      triangle.next = triangles[i + 1];
    }
    while (triangle = heap.pop()) {
      var previous = triangle.previous, next = triangle.next;
      if (triangle[1][2] < maxWeight)
        triangle[1][2] = maxWeight;
      else
        maxWeight = triangle[1][2];
      if (previous) {
        previous.next = next;
        previous[2] = triangle[2];
        update(previous);
      }
      if (next) {
        next.previous = previous;
        next[0] = triangle[0];
        update(next);
      }
    }
    return arc;
  });
  function update(triangle) {
    heap.remove(triangle);
    triangle[1][2] = weight(triangle);
    heap.push(triangle);
  }
  return {
    type: "Topology",
    bbox: topology.bbox,
    objects: topology.objects,
    arcs
  };
}

// node_modules/topojson-simplify/src/quantile.js
function quantile_default(topology, p) {
  var array = [];
  topology.arcs.forEach(function(arc) {
    arc.forEach(function(point) {
      if (isFinite(point[2])) {
        array.push(point[2]);
      }
    });
  });
  return array.length && quantile(array.sort(descending), p);
}
function quantile(array, p) {
  if (!(n = array.length))
    return;
  if ((p = +p) <= 0 || n < 2)
    return array[0];
  if (p >= 1)
    return array[n - 1];
  var n, h = (n - 1) * p, i = Math.floor(h), a = array[i], b = array[i + 1];
  return a + (b - a) * (h - i);
}
function descending(a, b) {
  return b - a;
}

// node_modules/topojson-simplify/src/simplify.js
function simplify_default(topology, minWeight) {
  minWeight = minWeight == null ? Number.MIN_VALUE : +minWeight;
  var arcs = topology.arcs.map(function(input) {
    var i = -1, j = 0, n = input.length, output = new Array(n), point;
    while (++i < n) {
      if ((point = input[i])[2] >= minWeight) {
        output[j++] = [point[0], point[1]];
      }
    }
    output.length = j;
    return output;
  });
  return {
    type: "Topology",
    transform: topology.transform,
    bbox: topology.bbox,
    objects: topology.objects,
    arcs
  };
}

// node_modules/topojson-simplify/src/spherical.js
var pi = Math.PI;
var tau = 2 * pi;
var quarterPi = pi / 4;
var radians = pi / 180;
var abs = Math.abs;
var atan2 = Math.atan2;
var cos = Math.cos;
var sin = Math.sin;
function halfArea(ring, closed) {
  var i = 0, n = ring.length, sum = 0, point = ring[closed ? i++ : n - 1], lambda0, lambda1 = point[0] * radians, phi1 = point[1] * radians / 2 + quarterPi, cosPhi0, cosPhi1 = cos(phi1), sinPhi0, sinPhi1 = sin(phi1);
  for (; i < n; ++i) {
    point = ring[i];
    lambda0 = lambda1, lambda1 = point[0] * radians;
    phi1 = point[1] * radians / 2 + quarterPi;
    cosPhi0 = cosPhi1, cosPhi1 = cos(phi1);
    sinPhi0 = sinPhi1, sinPhi1 = sin(phi1);
    var dLambda = lambda1 - lambda0, sdLambda = dLambda >= 0 ? 1 : -1, adLambda = sdLambda * dLambda, k = sinPhi0 * sinPhi1, u = cosPhi0 * cosPhi1 + k * cos(adLambda), v = k * sdLambda * sin(adLambda);
    sum += atan2(v, u);
  }
  return sum;
}
function sphericalRingArea(ring, interior) {
  var sum = halfArea(ring, true);
  if (interior)
    sum *= -1;
  return (sum < 0 ? tau + sum : sum) * 2;
}
function sphericalTriangleArea(t) {
  return abs(halfArea(t, false)) * 2;
}
export {
  bbox_default as bbox,
  feature_default2 as feature,
  filter_default as filter,
  filterAttached_default as filterAttached,
  filterAttachedWeight_default as filterAttachedWeight,
  filterWeight_default as filterWeight,
  merge_default as merge,
  mergeArcs,
  mesh_default as mesh,
  meshArcs,
  neighbors_default as neighbors,
  planarRingArea2 as planarRingArea,
  planarTriangleArea,
  presimplify_default as presimplify,
  quantile_default as quantile,
  quantize_default as quantize,
  simplify_default as simplify,
  sphericalRingArea,
  sphericalTriangleArea,
  topology_default as topology,
  transform_default2 as transform,
  untransform_default as untransform
};
//# sourceMappingURL=topojson.js.map
